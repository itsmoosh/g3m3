c
c     *******************************************************
c
      subroutine filldatav(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +        t,tt,tx,ty,tz,mx,my,mz,xmin,ymin,zmin,
     +        delx,dely,delz,vm,grd_xmin,grd_xmax,
     +        grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c     fill in diagnostic data cubes
c
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       dimension stuff(nx,ny,nz,ngrd),vx(nx,ny,nz),
     +             vy(nx,ny,nz),vz(nx,ny,nz)
       dimension t(mx,my,mz),tt(mx,my,mz),
     +           tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz)
c
c      load T stuff
c
        ddx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
        ddy=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
        ddz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
       vm=0.00001
       do 30 k=1,mz
        az=zmin+delz*(k-1)
        ak=1.+(az-grd_zmin(m))/ddz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        do 20 j=1,my
         ay=ymin+dely*(j-1)
         aj=1.+(ay-grd_ymin(m))/ddy
         j1=aj
         j2=j1+1
         dy=aj-j1
c
         do 10 i=1,mx
          ax=xmin+delx*(i-1)
          ai=1.+(ax-grd_xmin(m))/ddx
          i1=ai
          i2=i1+1
          dx=ai-i1
c
          t(i,j,k)=stuff(i1,j1,k1,mm)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +stuff(i1,j1,k2,mm)*(1.-dx)*(1.-dy)*(dz)
     +            +stuff(i1,j2,k1,mm)*(1.-dx)*(dy)*(1.-dz)
     +            +stuff(i1,j2,k2,mm)*(1.-dx)*(dy)*(dz)
     +            +stuff(i2,j1,k1,mm)*(dx)*(1.-dy)*(1.-dz)
     +            +stuff(i2,j1,k2,mm)*(dx)*(1.-dy)*(dz)
     +            +stuff(i2,j2,k1,mm)*(dx)*(dy)*(1.-dz)
     +            +stuff(i2,j2,k2,mm)*(dx)*(dy)*(dz)
c
          radius=sqrt(ax**2+ay**2+az**2)
          tt(i,j,k)=radius
c
          tx(i,j,k)=vx(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +vx(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +vx(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +vx(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +vx(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +vx(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +vx(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +vx(i2,j2,k2)*(dx)*(dy)*(dz)
c
          ty(i,j,k)=vy(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +vy(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +vy(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +vy(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +vy(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +vy(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +vy(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +vy(i2,j2,k2)*(dx)*(dy)*(dz)
c
          tz(i,j,k)=vz(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +vz(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +vz(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +vz(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +vz(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +vz(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +vz(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +vz(i2,j2,k2)*(dx)*(dy)*(dz)
c
          vm=amax1(vm,abs(tx(i,j,k)),abs(ty(i,j,k)),abs(tz(i,j,k)))
c
   10     continue
   20   continue
   30 continue
      vm=amax1(vm,0.00004)
c
      return
      end
c
c    *************************************************************
c
       subroutine flux_counter(qpx,qpy,qpz,hpx,hpy,hpz,
     +      opx,opy,opz,nx,ny,nz,ngrd,m,rmassq,rmassh,rmasso,
     +      grid_spacing,qflux_in,qflux_out,hflux_in,hflux_out,
     +      oflux_in,oflux_out)
c
c      calculates the mass flux being generated by the moon:
c        particles/cm-3/s
c
       dimension 
     +     qpx(nx,ny,nz,ngrd),qpy(nx,ny,nz,ngrd),qpz(nx,ny,nz,ngrd),
     +     hpx(nx,ny,nz,ngrd),hpy(nx,ny,nz,ngrd),hpz(nx,ny,nz,ngrd),
     +     opx(nx,ny,nz,ngrd),opy(nx,ny,nz,ngrd),opz(nx,ny,nz,ngrd)
c
c      initialize fluxes
c
       qflux_in=0.
       qflux_out=0.
       hflux_in=0.
       hflux_out=0.
       oflux_in=0.
       oflux_out=0.
c
c      do front and back walls
c
       i1=2
       i2=nx-1
c
       qflux1=0.
       qflux2=0.
       hflux1=0.
       hflux2=0.
       oflux1=0.
       oflux2=0.
c
       do k=1,nz
       do j=1,ny
         qflux1=qflux1+qpx(i1,j,k,m)
         hflux1=hflux1+hpx(i1,j,k,m)
         oflux1=oflux1+opx(i1,j,k,m)
c
         qflux2=qflux2+qpx(i2,j,k,m)
         hflux2=hflux2+hpx(i2,j,k,m)
         oflux2=oflux2+opx(i2,j,k,m)
       enddo
       enddo
       if(hflux1.gt.0)then
          qflux_in=qflux_in+qflux1*grid_spacing/rmassq
          hflux_in=hflux_in+hflux1*grid_spacing/rmassh
          oflux_in=oflux_in+oflux1*grid_spacing/rmasso
       else
          qflux_out=qflux_out-qflux1*grid_spacing/rmassq
          hflux_out=hflux_out-hflux1*grid_spacing/rmassh
          oflux_out=oflux_out-oflux1*grid_spacing/rmasso
       endif
       if(hflux2.lt.0)then
          qflux_in=qflux_in-qflux2*grid_spacing/rmassq
          hflux_in=hflux_in-hflux2*grid_spacing/rmassh
          oflux_in=oflux_in-oflux2*grid_spacing/rmasso
       else
          qflux_out=qflux_out+qflux2*grid_spacing/rmassq
          hflux_out=hflux_out+hflux2*grid_spacing/rmassh
          oflux_out=oflux_out+oflux2*grid_spacing/rmasso
       endif
c
c      do left and right walls
c
       j1=2
       j2=ny-1
c
       qflux1=0.
       qflux2=0.
       hflux1=0.
       hflux2=0.
       oflux1=0.
       oflux2=0.
c
       do k=1,nz
       do i=1,nx
         qflux1=qflux1+qpy(i,j1,k,m)
         hflux1=hflux1+hpy(i,j1,k,m)
         oflux1=oflux1+opy(i,j1,k,m)
c
         qflux2=qflux2+qpy(i,j2,k,m)
         hflux2=hflux2+hpy(i,j2,k,m)
         oflux2=oflux2+opy(i,j2,k,m)
       enddo
       enddo
       if(hflux1.gt.0)then
          qflux_in=qflux_in+qflux1*grid_spacing/rmassq
          hflux_in=hflux_in+hflux1*grid_spacing/rmassh
          oflux_in=oflux_in+oflux1*grid_spacing/rmasso
       else
          qflux_out=qflux_out-qflux1*grid_spacing/rmassq
          hflux_out=hflux_out-hflux1*grid_spacing/rmassh
          oflux_out=oflux_out-oflux1*grid_spacing/rmasso
       endif
       if(hflux2.lt.0)then
          qflux_in=qflux_in-qflux2*grid_spacing/rmassq
          hflux_in=hflux_in-hflux2*grid_spacing/rmassh
          oflux_in=oflux_in-oflux2*grid_spacing/rmasso
       else
          qflux_out=qflux_out+qflux2*grid_spacing/rmassq
          hflux_out=hflux_out+hflux2*grid_spacing/rmassh
          oflux_out=oflux_out+oflux2*grid_spacing/rmasso
       endif
c
c      do front and back walls
c
       k1=2
       k2=nz-1
c
       qflux1=0.
       qflux2=0.
       hflux1=0.
       hflux2=0.
       oflux1=0.
       oflux2=0.
c
       do j=1,ny
       do i=1,nx
         qflux1=qflux1+qpz(i,j,k1,m)
         hflux1=hflux1+hpz(i,j,k1,m)
         oflux1=oflux1+opz(i,j,k1,m)
c
         qflux2=qflux2+qpz(i,j,k2,m)
         hflux2=hflux2+hpz(i,j,k2,m)
         oflux2=oflux2+opz(i,j,k2,m)
       enddo
       enddo
       if(hflux1.gt.0)then
          qflux_in=qflux_in+qflux1*grid_spacing/rmassq
          hflux_in=hflux_in+hflux1*grid_spacing/rmassh
          oflux_in=oflux_in+oflux1*grid_spacing/rmasso
       else
          qflux_out=qflux_out-qflux1*grid_spacing/rmassq
          hflux_out=hflux_out-hflux1*grid_spacing/rmassh
          oflux_out=oflux_out-oflux1*grid_spacing/rmasso
       endif
       if(hflux2.lt.0)then
          qflux_in=qflux_in-qflux2*grid_spacing/rmassq
          hflux_in=hflux_in-hflux2*grid_spacing/rmassh
          oflux_in=oflux_in-oflux2*grid_spacing/rmasso
       else
          qflux_out=qflux_out+qflux2*grid_spacing/rmassq
          hflux_out=hflux_out+hflux2*grid_spacing/rmassh
          oflux_out=oflux_out+oflux2*grid_spacing/rmasso
       endif
c
       return
       end
c
c     **************************************************************
c
       subroutine crafdatv(bx,by,bz,
     +       qpx,qpy,qpz,qrho,qpresx,qpresy,qpresz,rmassq,
     +       hpx,hpy,hpz,hrho,hpresx,hpresy,hpresz,rmassh,
     +       opx,opy,opz,orho,opresx,opresy,opresz,rmasso,
     +       epres,nx,ny,nz,ngrd,m,craft,ncraft,n,ut,
     +       re_equiv,b_equiv,v_equiv,rho_equiv,gamma,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c       this subroutine will cut up array into a regular space
c       sub-grid and then write to binary file 13
c
c
       dimension bx(nx,ny,nz),by(nx,ny,nz),
     +     bz(nx,ny,nz),epres(nx,ny,nz,ngrd),
     +     qpx(nx,ny,nz,ngrd),qpy(nx,ny,nz,ngrd),qpz(nx,ny,nz,ngrd),
     +     qrho(nx,ny,nz,ngrd),qpresx(nx,ny,nz,ngrd),
     +     qpresy(nx,ny,nz,ngrd),qpresz(nx,ny,nz,ngrd),
     +     hpx(nx,ny,nz,ngrd),hpy(nx,ny,nz,ngrd),hpz(nx,ny,nz,ngrd),
     +     hrho(nx,ny,nz,ngrd),hpresx(nx,ny,nz,ngrd),
     +     hpresy(nx,ny,nz,ngrd),hpresz(nx,ny,nz,ngrd),
     +     opx(nx,ny,nz,ngrd),opy(nx,ny,nz,ngrd),opz(nx,ny,nz,ngrd),
     +     orho(nx,ny,nz,ngrd),opresx(nx,ny,nz,ngrd) ,
     +     opresy(nx,ny,nz,ngrd),opresz(nx,ny,nz,ngrd)
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

        dimension craft(4,ncraft)
c
c       set gridding
c
       delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
       dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
       delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
c      load T stuff
c
        az=craft(3,n)/re_equiv
        z1=1+(az-grd_zmin(m))/delz
        k1=z1
        k2=k1+1
        dz=(z1-k1)
c
        ay=craft(2,n)/re_equiv
        y1=1+(ay-grd_ymin(m))/dely
        j1=y1
        j2=j1+1
        dy=(y1-j1)
c
        ax=craft(1,n)/re_equiv
        x1=1+(ax-grd_xmin(m))/delx
        i1=x1
        i2=i1+1
        dx=(x1-i1)
c
          sbx=bx(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +bx(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +bx(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +bx(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +bx(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +bx(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +bx(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +bx(i2,j2,k2)*(dx)*(dy)*(dz)
          sby=by(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +by(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +by(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +by(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +by(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +by(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +by(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +by(i2,j2,k2)*(dx)*(dy)*(dz)
          sbz=bz(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +bz(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +bz(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +bz(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +bz(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +bz(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +bz(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +bz(i2,j2,k2)*(dx)*(dy)*(dz)
c
          sqpx=qpx(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +qpx(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +qpx(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +qpx(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +qpx(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +qpx(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +qpx(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +qpx(i2,j2,k2,m)*(dx)*(dy)*(dz)
          sqpy=qpy(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +qpy(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +qpy(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +qpy(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +qpy(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +qpy(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +qpy(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +qpy(i2,j2,k2,m)*(dx)*(dy)*(dz)
          sqpz=qpz(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +qpz(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +qpz(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +qpz(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +qpz(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +qpz(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +qpz(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +qpz(i2,j2,k2,m)*(dx)*(dy)*(dz)
          aqrho=qrho(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +qrho(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +qrho(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +qrho(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +qrho(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +qrho(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +qrho(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +qrho(i2,j2,k2,m)*(dx)*(dy)*(dz)
          qden=(aqrho+0.00001)/rmassq+0.0000001
          qpres1=qpresx(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +qpresx(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +qpresx(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +qpresx(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +qpresx(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +qpresx(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +qpresx(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +qpresx(i2,j2,k2,m)*(dx)*(dy)*(dz)
          qpres2=qpresy(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +qpresy(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +qpresy(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +qpresy(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +qpresy(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +qpresy(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +qpresy(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +qpresy(i2,j2,k2,m)*(dx)*(dy)*(dz)
          qpres3=qpresz(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +qpresz(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +qpresz(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +qpresz(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +qpresz(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +qpresz(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +qpresz(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +qpresz(i2,j2,k2,m)*(dx)*(dy)*(dz)
          rtq=sqrt( ( (qpres1+qpres2+qpres3)/3.)/qden)
c
          shpx=hpx(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +hpx(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +hpx(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +hpx(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +hpx(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +hpx(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +hpx(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +hpx(i2,j2,k2,m)*(dx)*(dy)*(dz)
          shpy=hpy(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +hpy(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +hpy(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +hpy(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +hpy(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +hpy(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +hpy(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +hpy(i2,j2,k2,m)*(dx)*(dy)*(dz)
          shpz=hpz(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +hpz(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +hpz(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +hpz(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +hpz(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +hpz(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +hpz(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +hpz(i2,j2,k2,m)*(dx)*(dy)*(dz)
          ahrho=hrho(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +hrho(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +hrho(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +hrho(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +hrho(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +hrho(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +hrho(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +hrho(i2,j2,k2,m)*(dx)*(dy)*(dz)
          hden=(ahrho+0.00001)/rmassh+0.0000001
          hpres1=hpresx(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +hpresx(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +hpresx(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +hpresx(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +hpresx(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +hpresx(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +hpresx(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +hpresx(i2,j2,k2,m)*(dx)*(dy)*(dz)
          hpres2=hpresy(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +hpresy(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +hpresy(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +hpresy(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +hpresy(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +hpresy(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +hpresy(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +hpresy(i2,j2,k2,m)*(dx)*(dy)*(dz)
          hpres3=hpresz(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +hpresz(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +hpresz(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +hpresz(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +hpresz(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +hpresz(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +hpresz(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +hpresz(i2,j2,k2,m)*(dx)*(dy)*(dz)
          rth=sqrt( ( (hpres1+hpres2+hpres3)/3.)/hden)
c
          sopx=opx(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +opx(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +opx(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +opx(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +opx(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +opx(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +opx(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +opx(i2,j2,k2,m)*(dx)*(dy)*(dz)
          sopy=opy(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +opy(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +opy(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +opy(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +opy(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +opy(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +opy(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +opy(i2,j2,k2,m)*(dx)*(dy)*(dz)
          sopz=opz(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +opz(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +opz(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +opz(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +opz(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +opz(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +opz(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +opz(i2,j2,k2,m)*(dx)*(dy)*(dz)
          aorho=orho(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +orho(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +orho(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +orho(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +orho(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +orho(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +orho(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +orho(i2,j2,k2,m)*(dx)*(dy)*(dz)
          oden=(aorho+0.00001)/rmasso +0.0000001  
          opres1=opresx(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +opresx(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +opresx(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +opresx(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +opresx(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +opresx(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +opresx(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +opresx(i2,j2,k2,m)*(dx)*(dy)*(dz)
          opres2=opresy(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +opresy(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +opresy(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +opresy(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +opresy(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +opresy(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +opresy(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +opresy(i2,j2,k2,m)*(dx)*(dy)*(dz)
          opres3=opresz(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +opresz(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +opresz(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +opresz(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +opresz(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +opresz(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +opresz(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +opresz(i2,j2,k2,m)*(dx)*(dy)*(dz)
          rto=sqrt( ( (opres1+opres2+opres3)/3.)/oden)
c
           epress=epres(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +epres(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +epres(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +epres(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +epres(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +epres(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +epres(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +epres(i2,j2,k2,m)*(dx)*(dy)*(dz)
           rte=sqrt(epress/(qden+oden+hden))
           vte=42.8*rte*v_equiv
c
c           put back in real units and gsm
c
            ax=-ax*re_equiv
            ay=-ay*re_equiv
            az=az*re_equiv
            sbx=-sbx*b_equiv
            sby=-sby*b_equiv
            sbz=sbz*b_equiv
            btot=sqrt(sbx**2+sby**2+sbz**2)
c
            vxq=-sqpx*v_equiv/(aqrho+0.00000001)
            vyq=-sqpy*v_equiv/(aqrho+0.00000001)
            vzq=sqpz*v_equiv/(aqrho+0.00000001)
            vtq=rtq/sqrt(rmassq)*v_equiv
            vtotq=sqrt(vxq**2+vyq**2+vzq**2)
c
            vxh=-shpx*v_equiv/(ahrho+0.00000001)
            vyh=-shpy*v_equiv/(ahrho+0.00000001)
            vzh=shpz*v_equiv/(ahrho+0.00000001)
            vth=rth/sqrt(rmassh)*v_equiv
            vtoth=sqrt(vxh**2+vyh**2+vzh**2)
c
            vxo=-sopx*v_equiv/(aorho+0.00000001)
            vyo=-sopy*v_equiv/(aorho+0.00000001)
            vzo=sopz*v_equiv/(aorho+0.00000001)
            vto=rto/sqrt(rmasso)*v_equiv
            vtoto=sqrt(vxo**2+vyo**2+vzo**2)
c
            qden=qden*rho_equiv
            hden=hden*rho_equiv
            oden=oden*rho_equiv
            rden=qden/(qden+oden+hden)
            xden=oden/(qden+oden+hden)
c
            rtx=hpressx/(hpressx+hpressy+hpressz+1.e-8)
            rty=hpressy/(hpressx+hpressy+hpressz+1.e-8)
            rtz=hpressz/(hpressx+hpressy+hpressz+1.e-8)
c
            mout=50+n
            write(mout,*)ut,ax,ay,az
            write(mout,*)btot,sbx,sby,sbz
            write(mout,*)qden,vxq,vyq,vzq
            write(mout,*)hden,vxh,vyh,vzh
            write(mout,*)oden,vxo,vyo,vzo
            write(mout,*)rden,vte,vtq,vto
            write(mout,*)xden,rtx,rty,rtz
c  30 continue
c
      return
      end
c
c     ********************************************
c
      subroutine plot1d(xary,yary,npt,time,label)
c
      dimension xary(npt),yary(npt),xmax(2),ymax(2)
      character*8 label
      character*20 title
c
      fmax=yary(1)
      fmin=fmax
      do 10 i=2,npt
        fmax=amax1(yary(i),fmax)
        fmin=amin1(yary(i),fmin)
   10 continue
c
      if((fmax.gt.0.0).and.(fmin.gt.0.0))fmin=0.0
      if((fmax.lt.0.0).and.(fmin.lt.0.0))fmax=0.0
c
      xmax(2)=xary(npt)
      xmax(1)=xary(1)
      ymax(2)=fmax
      ymax(1)=fmin
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
      write(title,'(f7.3)')time
      title='t= '//title
      call wtstr(.75,.97,title,1,0,0)
      call ezxy(xmax,ymax,2,label)
      call curve(xary,yary,npt)
      call agseti('SET.',1)
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
c
      return
      end
c
c     **************************************************************
c
       subroutine aurora_cur(stuff,nx,ny,nz,m,radstrt,re_equiv,
     +     rearth,iside,time,save_dat,add_two,label,ncon,write_dat,
     +          b_equiv,planet_rad,tot_cur,peak_cur,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      this subroutine will try to make  close up image
c      of stuff near the auroral regions at a fixed distance radstrt
c       re_equiv converts grid units to R_E
c        add_two adds two current densities to produce
c                 a total auroral map
c
      common /space/sdata(91,91),tdata(91,91),
     +               work(91,91),clat(91,91)

      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
c
       dimension stuff(nx,ny,nz) 	
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       character*4 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       logical save_dat,add_two,write_dat
c
c     for no line labeling set ILAB  to zero
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
      call isoclrs
      ILAB=0
      IOFFM=1
      IRECMJ=1
      IRECTX=1
      IRECMN=1
c
c       conversion of CURRENT simulation units to uA/m^2 and to MA
c                 map to Earth's surface so A ~ R**3
c
        scale_cur= 10. * b_equiv *((radstrt*re_equiv)**3)/
     +              (4.* 3.1416*re_equiv*planet_rad)
c       write(6,*)b_equiv,radstrt,re_equiv,planet_rad
c       write(6,*)' current density in',scale_cur,' uA/m^2'
        scale_amps=((planet_rad/1000.)**2)*scale_cur
c       write(6,*)'totcur scale',scale_amps
        amp_up=0.
        amp_down=0. 
        peak_cur_up=0.
        peak_cur_down=0.

c
c      dimension for plotted array
c
       mx=91
       my=91
       my2=my/2+1
       mx2=mx/2+1
c
c     re_equiv is the physical distance of a grid unit in Re's
c      theta_range is the latitudes for the polar plot and is set
c                    at 35 degrees
c       theta_equiv converts latitude at the earth surface to
c                   latiude at radstrt
c
c       re_equiv=0.84
       theta_equiv=sqrt(re_equiv*radstrt)
c      theta_range=0.698132  ! 40 degrees
       theta_range=0.6108652  ! 35 degrees
       degrees=57.3*theta_range
       del_theta=theta_range/float(mx2-1)
c
       rads=degrees/57.3
       del_rads=rads/float(mx2-1)
c
c      initialize work array
c
       do 10 j=1,my
       do 10 i=1,mx
         work(i,j)=0.0
   10 continue
c
      delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
      dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
      delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
       do 50 j=1,my
       do 50 i=1,mx
c
c         find equivalent latitude
c
           dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
           dlat=amax1(dlat,0.0000001)
           alat=dlat*del_theta*theta_equiv  ! equiv theta at sample point
c
           theta=dlat*del_rads  ! theta in ionosphere
           ascale=del_rads*sin(theta)/(dlat+1.)
c
           if(alat.gt.1.55)goto 50
           cost=cos(alat)
           sint=sin(alat)
c
c         find equivalent longitude
c
           cosp=(i-mx2)/dlat
           sinp=(j-my2)/dlat
c
c          find position on grid
c
           z1=iside*(radstrt*cost)
           x1=radstrt*sint*cosp
c
c       dipole space to real space
c
           ax=x1*cos_tilt+z1*sin_tilt+xdip
           az=-x1*sin_tilt+z1*cos_tilt+zdip
           ay=(radstrt*sint*sinp+ydip)
c
c          interpolate data to grid point
c
c
        ak=1.+(az-grd_zmin(m))/delz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        aj=1.+(ay-grd_ymin(m))/dely
        j1=aj
        j2=j1+1
        dy=aj-j1
c
        ai=1.+(ax-grd_xmin(m))/delx
        i1=ai
        i2=i1+1
        dx=ai-i1
c
        acur=stuff(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +stuff(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +stuff(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +stuff(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +stuff(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +stuff(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +stuff(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +stuff(i2,j2,k2)*(dx)*(dy)*(dz)
c
        acur=acur*scale_amps  !in physical unit uA/m**2
        work(i,j)=acur
        totcur=ascale*acur
        if(acur.gt.0)then
          amp_up=amp_up+totcur
          peak_cur_up=amax1(peak_cur_up,acur)
        else
          amp_down=amp_down+totcur
          peak_cur_down=amin1(peak_cur_down,acur)
        endif
c
   50 continue
c
      tot_cur=(amp_up-amp_down)/2.
      peak_cur=amax1(peak_cur_up,-peak_cur_down)
      write(6,*)'totcur',amp_up,amp_down,tot_cur
      write(6,*)'peak current',peak_cur_up,peak_cur_down,peak_cur
c
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : aurora'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.15,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      fmax=work(1,1)
      fmin=fmax
      do 100 j=1,my
      do 100 i=1,mx
        fmax=amax1(fmax,work(i,j))
        fmin=amin1(fmin,work(i,j))
  100 continue
c
      if (fmin.ge.0.0)then 
        cmin=1.05*fmin
      else 
         cmin=0.95*fmin
      endif 
c
      if(fmax.ge.0.0) then
        cmax=0.95*fmax
      else
        cmax=1.05*fmax
      endif
      finc=(cmax-cmin)/float(ncon-1)
      write(title,'(f7.2)')fmin
      title='fmin'//title
      call wtstr(.1,.98,title,1,0,0)
      write(title,'(f7.2)')fmax
      title='fmax'//title
      call wtstr(.3,.98,title,1,0,0)
c
      write(title,'(f7.3)')amp_up
      title='tot_up'//title
      call wtstr(.1,.96,title,1,0,0)
      write(title,'(f7.3)')amp_down
      title='tot_down'//title
      call wtstr(.45,.96,title,1,0,0)
c
      call gsplci(1)
      call conrec(work,mx,mx,my,cmin,cmax,finc,0,-1,-1012)
c
c     make constant latitude circles
c
      dd=degrees/float(mx2-1)
      fmax=0.
      do 110 j=1,my
      do 110 i=1,mx
         dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
          clat(i,j)=90.-dlat*dd
          fmax=amax1(fmax,clat(i,j))
  110 continue
c
c     ILAB=1
      call conrec(clat,mx,mx,my,60.,90.,10.,0,-1,-1012)
c
c     save data if required
c
      if(save_dat)then      
        if(iside.gt.0) then
        do 120 j=1,my
        do 120 i=1,mx
            sdata(i,j)=work(i,j)
  120 continue 
        else
        do 121 j=1,my
        do 121 i=1,mx
            tdata(i,j)=work(i,j)
  121 continue
       endif
      endif
c
c      output data to bin file if necessary
c
       if(write_dat)then
         write(8)time,work
c       do 122 j=1,my
c       do 122 i=1,mx
c           write(8,*)work(i,j)
c 122  continue 
       endif
c
c        
       if(.not.add_two)return
c    
      ILAB=0
       if(iside.gt.0)then
         do 130 j=1,my
         do 130 i=1,mx
            work(i,j)=work(i,j)+sdata(i,j)
  130  continue
         else
         do 131 j=1,my
         do 131 i=1,mx
            work(i,j)=work(i,j)+tdata(i,j)
  131 continue
      endif
c
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : Total Aur'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.85,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      fmax=work(1,1)
      fmin=fmax
      do 140 j=1,my
      do 140 i=1,mx
        fmax=amax1(fmax,work(i,j))
        fmin=amin1(fmin,work(i,j))
  140 continue
c
      if (fmin.ge.0.0)then 
        cmin=1.05*fmin
      else 
         cmin=0.95*fmin
      endif 
c
      if(fmax.ge.0.0) then
        cmax=0.95*fmax
      else
        cmax=1.05*fmax
      endif
      finc=(cmax-cmin)/float(ncon-1)
      write(title,'(f6.3)')fmin
      title='fmin'//title
      call wtstr(.1,.98,title,1,0,0)
      write(title,'(f6.3)')fmax
      title='fmax'//title
      call wtstr(.25,.98,title,1,0,0)
      call conrec(work,mx,mx,my,cmin,cmax,finc,0,-1,-1012)
c
c     ILAB=1
      call conrec(clat,mx,mx,my,60.,90.,10.,0,-1,-1012)
      return
      end
c
c     **********************************************************
c
       subroutine aurora_bfld(bx,by,bz,nx,ny,nz,m,rx,
     +            xmin,xmax,ymin,ymax,zmin,zmax,iside,
     +            add_dip,radstrt,re_equiv,rearth,time,label,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c       this subroutine seeks to determine open field
c             line positions
c
       common /space/work(91,91),clat(91,91),
     +     xray(1000),yray(1000),zray(1000)
       common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
c
       dimension bx(nx,ny,nz),by(nx,ny,nz),bz(nx,ny,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       character*4 llbs(14),wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       logical add_dip,roc
c
c
c      dimension for plotted array
c
       maxpts=1000
       mx=91
       my=91
       my2=my/2+1
       mx2=mx/2+1
c
       theta_equiv=sqrt(re_equiv*radstrt)
       theta_range=0.6108652
       degrees=57.3*theta_range
       del_theta=theta_range/float(mx2-1)
       rx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
c
c      initialize work array
c
       do 10 j=1,my
       do 10 i=1,mx
         work(i,j)=0.0
   10 continue
c
       do 50 j=1,my
       do 50 i=1,mx
c
        closed=0.
c
c         find equivalent latitude
c
           dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
           dlat=amax1(dlat,0.0000001)
           alat=dlat*del_theta*theta_equiv
           if(alat.gt.1.55)goto 50
           cost=cos(alat)
           sint=sin(alat)
c
c         find equivalent longitude
c
           cosp=(i-mx2)/dlat
           sinp=(j-my2)/dlat
c
c          find position on grid
c
           z1=iside*(radstrt*cost)
           x1=radstrt*sint*cosp
c
c       dipole space to real space
c
           ax=x1*cos_tilt+z1*sin_tilt+xdip
           az=-x1*sin_tilt+z1*cos_tilt+zdip
           ay=(radstrt*sint*sinp+ydip)
c
        dir=-rx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,zmin,zmax,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        find the radial distance of end point
c
         ar=sqrt((xray(npts)-xdip)**2+(yray(npts)-ydip)**2
     +           +(zray(npts)-zdip)**2)
         if(ar.le.rearth+2.*rx)closed=closed+1.
c
        dir=rx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,zmin,zmax,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +   grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        find the radial distance of end point
c
         ar=sqrt(xray(npts) **2+yray(npts) **2+zray(npts)**2)
         if(ar.le.rearth+2.*rx)closed=closed+1.
         work(i,j)=closed
   50 continue
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : separatrix'
      call wtstr(.3,.975,label,2,0,0)
      call wtstr(.5,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.15,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      call conrec(work,mx,mx,my,1.4,1.6,.1,0,-1,-1012)
c
c     make constant latitude circles
c
      dd=degrees/float(mx2-1)
      fmax=0.
      do 110 j=1,my
      do 110 i=1,mx
         dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
          clat(i,j)=90.-dlat*dd
          fmax=amax1(fmax,clat(i,j))
  110 continue
c
c     ILAB=1
      call conrec(clat,mx,mx,my,60.,90.,10.,0,-1,-1012)   
c
      return 
      end
c
c     **************************************************************
c
       subroutine auroras(press,rho,bsx,bsy,bsz,
     +            nx,ny,nz,ngrd,m,radstrt,re_equiv,rearth,iside,
     +       time,save_dat,add_dip,label,ncon,write_dat,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      this subroutine will try to make  close up image
c      of stuff near the auroral regions at a fixed distance radstrt
c       re_equiv converts grid units to R_E
c        add_two adds two current densities to produce
c                 a total auroral map
c

      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
      common /space/sdata(91,91),tdata(91,91),
     +               work(91,91),clat(91,91),chot(91,91)
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
c
       dimension press(nx,ny,nz),rho(nx,ny,nz),
     +         bsx(nx,ny,nz),bsy(nx,ny,nz),bsz(nx,ny,nz)
       character*4 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       logical save_dat,add_dip,write_dat
c
c     for no line labeling set ILAB  to zero
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
c
      ILAB=0
      add_dip=.false.
c
c      dimension for plotted array
c
       mx=91
       my=91
       my2=my/2+1
       mx2=mx/2+1
c
c     re_equiv is the physical distance of a grid unit in Re's
c      theta_range is the latitudes for the polar plot and is set
c                    at 35 degrees
c       theta_equiv converts latitude at the earth surface to
c                   latiude at radstrt
c
c       re_equiv=0.84
       theta_equiv=sqrt(re_equiv*radstrt)
       theta_range=0.698132  ! 40 degrees
c      theta_range=0.6108652  ! 35 degrees
       degrees=57.3*theta_range
       del_theta=theta_range/float(mx2-1)
c
c      initialize work array
c
       do 10 j=1,my
       do 10 i=1,mx
         work(i,j)=0.0
         chot(i,j)=0.0
   10 continue
c
      delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
      dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
      delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
      xmin=grd_xmin(m)+1.
      xmax=grd_xmax(m)-1.
      ymin=grd_ymin(m)+1.
      ymax=grd_ymax(m)-1.
      zmin=grd_zmin(m)+1.
      zmax=grd_zmax(m)-1.
c
       do 50 j=1,my
       do 50 i=1,mx
c
c         find equivalent latitude
c
           dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
           dlat=amax1(dlat,0.0000001)
           alat=dlat*del_theta*theta_equiv
           if(alat.gt.1.55)goto 50
           cost=cos(alat)
           sint=sin(alat)
c
c         find equivalent longitude
c
           cosp=(i-mx2)/dlat
           sinp=(j-my2)/dlat
c
c          find position on grid
c
           z1=iside*(radstrt*cost)
           x1=radstrt*sint*cosp
c
c       dipole space to real space
c
           ax=x1*cos_tilt+z1*sin_tilt+xdip
           az=-x1*sin_tilt+z1*cos_tilt+zdip
           ay=(radstrt*sint*sinp+ydip)
c
c          interpolate data to grid point
c
c
        ak=1.+(az-grd_zmin(m))/delz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        aj=1.+(ay-grd_ymin(m))/dely
        j1=aj
        j2=j1+1
        dy=aj-j1
c
        ai=1.+(ax-grd_xmin(m))/delx
        i1=ai
        i2=i1+1
        dx=ai-i1
c
c         trace fld line and find max energy along it
c
        ergies=0.
        rhod=0.
        dir=-delx
        call rungea(bsx,bsy,bsz,press,rho,nx,ny,nz,
     +      m,ax,ay,az,xmin,xmax,ymin,ymax,zmin,zmax,
     +      add_dip,ergies,rhod,maxpts,dir,
     +      delx,dely,delz,rearth,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
        dir=+delx
        call rungea(bsx,bsy,bsz,press,rho,nx,ny,nz,
     +      m,ax,ay,az,xmin,xmax,ymin,ymax,zmin,zmax,
     +      add_dip,ergies,rhod,maxpts,dir,
     +      delx,dely,delz,rearth,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)

        chot(i,j)=ergies
c
   50 continue
c
c     initialize viewport and frame headings
c     
c     plot intensity = current*energy
c
      fmax=work(1,1)
      fmin=fmax
      do 115 j=1,my
      do 115 i=1,mx
        fmax=amax1(fmax,chot(i,j))
        fmin=amin1(fmin,chot(i,j))
  115 continue
c     
      call frame
      call gselnt(0)
      call gsplci(18)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : intensity'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.15,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.1,.98,title,1,0,0)
      title='fmax'//title
      write(title,'(f7.4)')fmax
      call wtstr(.25,.98,title,1,0,0)
      if(fmin*fmax.lt.0.)then
        cmax=amax1(fmax,abs(fmin))
        cmin=-cmax
      else
        cmax=fmax
        cmin=fmin
      endif
      clev=(cmax-cmin)/(ncon+1.)
c     if(.not.start) call cnrccf(chot,mx,mx,my,cmin,
c    +             cmax,clev,0,-1,-1012,2.5,0,1)
      IRECMN=18
      call conrec(chot,mx,mx,my,cmin,
     +             cmax,clev,0,-1,-1012)
c
c     plot constant latitude circles
c
      dd=degrees/float(mx2-1)
      fmax=0.
      do 120 j=1,my
      do 120 i=1,mx
         dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
          clat(i,j)=90.-dlat*dd
          fmax=amax1(fmax,clat(i,j))
  120 continue
      call conrec(clat,mx,mx,my,50.,90.,10.,0,-1,-1012)
c
c     save data if required
c
      if(write_dat)then      
       write(8)time,chot
      endif
      return
      end
c
c     **************************************************************
c
       subroutine aurora_pot(efldx,efldy,efldz,bsx,bsy,bsz,
     +            nx,ny,nz,ngrd,m,radstrt,re_equiv,iside,rearth,
     +            time,save_dat,add_dip,label,ncon,write_dat,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      this subroutine will try to make  close up image
c      of stuff near the auroral regions at a fixed distance radstrt
c       re_equiv converts grid units to R_E
c        add_two adds two current densities to produce
c                 a total auroral map
c
      common /space/sdata(91,91),tdata(91,91),
     +               work(91,91),clat(91,91),chot(91,91) 
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 

       dimension efldx(nx,ny,nz),efldy(nx,ny,nz),efldz(nx,ny,nz),
     +         bsx(nx,ny,nz),bsy(nx,ny,nz),bsz(nx,ny,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       character*4 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       logical save_dat,add_dip,write_dat
c
c     for no line labeling set ILAB  to zero
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
c
      ILAB=0
      add_dip=.false.
c
c      dimension for plotted array
c
       mx=91
       my=91
       my2=my/2+1
       mx2=mx/2+1
c
c     re_equiv is the physical distance of a grid unit in Re's
c      theta_range is the latitudes for the polar plot and is set
c                    at 35 degrees
c       theta_equiv converts latitude at the earth surface to
c                   latiude at radstrt
c
c       re_equiv=0.84
       theta_equiv=sqrt(re_equiv*radstrt)
c      theta_range=0.698132  ! 40 degrees
       theta_range=0.6108652  ! 35 degrees
       degrees=57.3*theta_range
       del_theta=theta_range/float(mx2-1)
c
c      initialize work array
c
       do 10 j=1,my
       do 10 i=1,mx
         work(i,j)=0.0
         chot(i,j)=0.0
   10 continue
c
      delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
      dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
      delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
      xmin=grd_xmin(m)+1.
      xmax=grd_xmax(m)-1.
      ymin=grd_ymin(m)+1.
      ymax=grd_ymax(m)-1.
      zmin=grd_zmin(m)+1.
      zmax=grd_zmax(m)-1.
c
       do 50 j=1,my
       do 50 i=1,mx
c
c         find equivalent latitude
c
           dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
           dlat=amax1(dlat,0.0000001)
           alat=dlat*del_theta*theta_equiv
           if(alat.gt.1.55)goto 50
           cost=cos(alat)
           sint=sin(alat)
c
c         find equivalent longitude
c
           cosp=(i-mx2)/dlat
           sinp=(j-my2)/dlat
c
c          find position on grid
c
           z1=iside*(radstrt*cost)
           x1=radstrt*sint*cosp
c
c       dipole space to real space
c
           ax=x1*cos_tilt+z1*sin_tilt+xdip
           az=-x1*sin_tilt+z1*cos_tilt+zdip
           ay=(radstrt*sint*sinp+ydip)
c
c         trace fld line and find max energy along it
c
        dir=-delx
        call rungeb(efldx,efldy,efldz,bsx,bsy,bsz,nx,ny,nz,
     +      ngrd,m,delx,ax,ay,az,xmin,xmax,ymin,ymax,
     +    zmin,zmax,add_dip,pot1,maxpts,dir,rearth,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
        dir=+delx
        call rungeb(efldx,efldy,efldz,bsx,bsy,bsz,nx,ny,nz,
     +      ngrd,m,delx,ax,ay,az,xmin,xmax,ymin,ymax,
     +    zmin,zmax,add_dip,pot2,maxpts,dir,rearth,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)

        chot(i,j)=iside*(pot1-pot2)
c
   50 continue
c
c     initialize viewport and frame headings
c     
c     plot intensity = current*energy
c
      fmax=work(1,1)
      fmin=fmax
      do 115 j=1,my
      do 115 i=1,mx
        fmax=amax1(fmax,chot(i,j))
        fmin=amin1(fmin,chot(i,j))
  115 continue
c     
      call frame
      call gselnt(0)
      call gsplci(18)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : intensity'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.15,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.1,.98,title,1,0,0)
      title='fmax'//title
      write(title,'(f7.4)')fmax
      call wtstr(.25,.98,title,1,0,0)
c     if(fmin*fmax.lt.0.)then
c       cmax=amax1(fmax,abs(fmin))
c       cmin=-cmax
c     else
c       cmax=0.5*fmax
c       cmin=fmin
c     endif
      cmax=0.15    !20 keV
      cmin=-0.15
      clev=(cmax-cmin)/(ncon+1.)
c     if(.not.start) call cnrccf(chot,mx,mx,my,cmin,
c    +             cmax,clev,0,-1,-1012,2.5,0,1)
      IRECMN=18
      call conrec(chot,mx,mx,my,cmin,
     +             cmax,clev,0,-1,-1012)
c
c     plot constant latitude circles
c
      dd=degrees/float(mx2-1)
      fmax=0.
      do 120 j=1,my
      do 120 i=1,mx
         dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
          clat(i,j)=90.-dlat*dd
          fmax=amax1(fmax,clat(i,j))
  120 continue
      call conrec(clat,mx,mx,my,60.,90.,10.,0,-1,-1012)
c
c     save data if required
c
      if(write_dat)then      
       write(8)time,chot
      endif
      return
      end
c
c     **************************************************************
c
       subroutine aurora(stuff,nx,ny,nz,m,radstrt,re_equiv,iside,
     +           time, save_dat,add_two,label,ncon,write_dat,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      this subroutine will try to make  close up image
c      of stuff near the auroral regions at a fixed distance radstrt
c       re_equiv converts grid units to R_E
c        add_two adds two current densities to produce
c                 a total auroral map
c
      common /space/sdata(91,91),tdata(91,91),
     +                           work(91,91),clat(91,91)
      dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd) 
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 

c
       dimension stuff(nx,ny,nz)
       character*4 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       logical save_dat,add_two,write_dat
c
c     for no line labeling set ILAB  to zero
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
      call isoclrs
      ILAB=0
      IOFFM=1
      IRECMJ=1
      IRECTX=1
      IRECMN=1
c
c      dimension for plotted array
c
       mx=91
       my=91
       my2=my/2+1
       mx2=mx/2+1
c
c     re_equiv is the physical distance of a grid unit in Re's
c      theta_range is the latitudes for the polar plot and is set
c                    at 35 degrees
c       theta_equiv converts latitude at the earth surface to
c                   latiude at radstrt
c
c       re_equiv=0.84
       theta_equiv=sqrt(re_equiv*radstrt)
c      theta_range=0.698132  ! 40 degrees
       theta_range=0.6108652  ! 35 degrees
       degrees=57.3*theta_range
       del_theta=theta_range/float(mx2-1)
c
c      initialize work array
c
       do 10 j=1,my
       do 10 i=1,mx
         work(i,j)=0.0
   10 continue
c
      delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
      dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
      delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
       do 50 j=1,my
       do 50 i=1,mx
c
c         find equivalent latitude
c
           dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
           dlat=amax1(dlat,0.0000001)
           alat=dlat*del_theta*theta_equiv
           if(alat.gt.1.55)goto 50
           cost=cos(alat)
           sint=sin(alat)
c
c         find equivalent longitude
c
           cosp=(i-mx2)/dlat
           sinp=(j-my2)/dlat
c
c          find position on grid
c
           z1=iside*(radstrt*cost)
           x1=radstrt*sint*cosp
c
c       dipole space to real space
c
           ax=x1*cos_tilt+z1*sin_tilt+xdip
           az=-x1*sin_tilt+z1*cos_tilt+zdip
           ay=(radstrt*sint*sinp+ydip)
c
c          interpolate data to grid point
c
c
        ak=1.+(az-grd_zmin(m))/delz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        aj=1.+(ay-grd_ymin(m))/dely
        j1=aj
        j2=j1+1
        dy=aj-j1
c
        ai=1.+(ax-grd_xmin(m))/delx
        i1=ai
        i2=i1+1
        dx=ai-i1
c
        acur=stuff(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +stuff(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +stuff(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +stuff(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +stuff(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +stuff(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +stuff(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +stuff(i2,j2,k2)*(dx)*(dy)*(dz)
c
          work(i,j)=acur
c
   50 continue
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : aurora'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.15,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      fmax=work(1,1)
      fmin=fmax
      do 100 j=1,my
      do 100 i=1,mx
        fmax=amax1(fmax,work(i,j))
        fmin=amin1(fmin,work(i,j))
  100 continue
c
      if (fmin.ge.0.0)then 
        cmin=1.05*fmin
      else 
         cmin=0.95*fmin
      endif 
c
      if(fmax.ge.0.0) then
        cmax=0.95*fmax
      else
        cmax=1.05*fmax
      endif
      finc=(cmax-cmin)/float(ncon-1)
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.1,.98,title,1,0,0)
      write(title,'(f7.4)')fmax
      title='fmax'//title
      call wtstr(.25,.98,title,1,0,0)
      call gsplci(1)
      call conrec(work,mx,mx,my,cmin,cmax,finc,0,-1,-1012)
c
c     make constant latitude circles
c
      dd=degrees/float(mx2-1)
      fmax=0.
      do 110 j=1,my
      do 110 i=1,mx
         dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
          clat(i,j)=90.-dlat*dd
          fmax=amax1(fmax,clat(i,j))
  110 continue
c
c     ILAB=1
      call conrec(clat,mx,mx,my,60.,90.,10.,0,-1,-1012)
c
c     save data if required
c
      if(save_dat)then      
        if(iside.gt.0) then
        do 120 j=1,my
        do 120 i=1,mx
            sdata(i,j)=work(i,j)
  120 continue 
        else
        do 121 j=1,my
        do 121 i=1,mx
            tdata(i,j)=work(i,j)
  121 continue
       endif
      endif
c
c      output data to bin file if necessary
c
       if(write_dat)then
         write(8)time,work
c       do 122 j=1,my
c       do 122 i=1,mx
c           write(8,*)work(i,j)
c 122  continue 
       endif
c
c        
       if(.not.add_two)return
c    
      ILAB=0
       if(iside.gt.0)then
         do 130 j=1,my
         do 130 i=1,mx
            work(i,j)=work(i,j)+sdata(i,j)
  130  continue
         else
         do 131 j=1,my
         do 131 i=1,mx
            work(i,j)=work(i,j)+tdata(i,j)
  131 continue
      endif
c
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : Total Aur'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.15,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      fmax=work(1,1)
      fmin=fmax
      do 140 j=1,my
      do 140 i=1,mx
        fmax=amax1(fmax,work(i,j))
        fmin=amin1(fmin,work(i,j))
  140 continue
c
      if (fmin.ge.0.0)then 
        cmin=1.05*fmin
      else 
         cmin=0.95*fmin
      endif 
c
      if(fmax.ge.0.0) then
        cmax=0.95*fmax
      else
        cmax=1.05*fmax
      endif
      finc=(cmax-cmin)/float(ncon-1)
      write(title,'(f6.3)')fmin
      title='fmin'//title
      call wtstr(.1,.98,title,1,0,0)
      write(title,'(f6.3)')fmax
      title='fmax'//title
      call wtstr(.25,.98,title,1,0,0)
      call conrec(work,mx,mx,my,cmin,cmax,finc,0,-1,-1012)
c
c     ILAB=1
      call conrec(clat,mx,mx,my,60.,90.,10.,0,-1,-1012)
      return
      end
c
c     **************************************************************
c
       subroutine convect(vx,vy,vz,nx,ny,nz,m,radstrt,
     +                    re_equiv,iside,time,label,write_dat,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      this subroutine will try to make convection pattern
c         over auroral oval
c      sdata tdata included to allow passing of data between 
c         successive calls of aurora
      common /space/sdata(61,61),tdata(61,61),work(31,31),
     +    avx(31,31),avy(31,31)
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0
c
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       dimension vx(nx,ny,nz),vy(nx,ny,nz),vz(nx,ny,nz),spv(2)
       character*4 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       logical write_dat
c
c     for no line labeling set ILAB  to zero
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
c
      ILAB=0
c
c      dimension for plotted array
c
       mx=31
       my=31
       my2=my/2+1
       mx2=mx/2+1
c
c     re_equiv is the physical distance of a grid unit in Re's
c      theta_range is the latitudes for the polar plot and is set
c                    at 35 degrees
c       theta_equiv converts latitude at the earth surface to
c                   latiude at radstrt
c
c       re_equiv=0.84
       theta_equiv=sqrt(re_equiv*radstrt)
       theta_range=0.6108652
       degrees=57.3*theta_range
       del_theta=theta_range/float(mx2-1)
c
c      initialize work array
c
       do 10 j=1,my
       do 10 i=1,mx
         work(i,j)=0.0
         avx(i,j)=0.0
         avy(i,j)=0.0
   10 continue
c
      delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
      dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
      delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
       do 50 j=1,my
       do 50 i=1,mx
c
c         find equivalent latitude
c
           dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
           dlat=amax1(dlat,0.0000001)
           alat=dlat*del_theta*theta_equiv
           if(alat.gt.1.55)goto 50
           cost=cos(alat)
           sint=sin(alat)
c
c         find equivalent longitude
c
           cosp=(i-mx2)/dlat
           sinp=(j-my2)/dlat
c
c          find position on grid
c
           z1=iside*(radstrt*cost)
           x1=radstrt*sint*cosp
c
c       dipole space to real space
c
           ax=x1*cos_tilt+z1*sin_tilt+xdip
           az=-x1*sin_tilt+z1*cos_tilt+zdip
           ay=(radstrt*sint*sinp+ydip)
           ar=sqrt((ax-xdip)**2+(ay-ydip)**2+(az-zdip)**2)+0.0000001
c
c          interpolate data to grid point
c
c
        ak=1.+(az-grd_zmin(m))/delz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        aj=1.+(ay-grd_ymin(m))/dely
        j1=aj
        j2=j1+1
        dy=aj-j1
c
        ai=1.+(ax-grd_xmin(m))/delx
        i1=ai
        i2=i1+1
        dx=ai-i1
c
        bvx=vx(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +vx(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +vx(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +vx(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +vx(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +vx(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +vx(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +vx(i2,j2,k2)*(dx)*(dy)*(dz)
        bvy=vy(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +vy(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +vy(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +vy(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +vy(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +vy(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +vy(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +vy(i2,j2,k2)*(dx)*(dy)*(dz)
        bvz=vz(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +vz(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +vz(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +vz(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +vz(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +vz(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +vz(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +vz(i2,j2,k2)*(dx)*(dy)*(dz)
c
c          find tangential components
c
          cost=iside*(az-zdip)/ar
          bvz=iside*bvz
          sint=sqrt((ax-xdip)**2+(ay-ydip)**2)/ar
          cosp=(ax-xdip)/(ar*sint+0.000001)
          sinp=(ay-ydip)/(ar*sint+0.000001)
          vr=bvx*sint*cosp+bvy*sint*sinp+bvz*cost
          vtheta=bvx*cost*cosp+bvy*cost*sinp-bvz*sint
          vphi=-bvx*sinp+bvy*cosp
c
c        restructure magnetic field without radial velocity component
c
          vr=0.     
          bvx=vr*sint*cosp+vtheta*cost*cosp-vphi*sinp
          bvy=vr*sint*sinp+vtheta*cost*sinp+vphi*cosp
          bvz=vr*cost-vtheta*sint
          avx(i,j)=vtheta*cosp-vphi*sinp
          avy(i,j)=vtheta*sinp+vphi*cosp
c         avx(i,j)=bvx
c         avy(i,j)=bvy
c
   50 continue
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
c     set color table 
c
      call sflush
      call isorb
c
      title=' : convect'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='lat. '
      call wtstr(.15,.96,title,1,0,0)
      write(title,'(f7.3)')degrees
      call wtstr(.2,.96,title,1,0,0)
c
      xcmin=0.
      xcmax=0.
      ycmin=0.
      ycmax=0.
      do 75 j=1,my
        do 75 i=1,mx
        xcmav=amax1(avx(i,j),xcmav)
        xcmin=amin1(avx(i,j),xcmin)
        ycmav=amax1(avy(i,j),ycmav)
        ycmin=amin1(avy(i,j),ycmin)
   75 continue
c
      if(abs(xcmin).gt.xcmax)xcmax=abs(xcmin)
      if(abs(ycmin).gt.ycmax)ycmax=abs(ycmin)
      cmax=amax1(xcmax,ycmax)
      if(cmax.gt.1.e-4)then
       title='maxspeed '
       call wtstr(.3,.96,title,1,0,0)
       write(title,'(f6.4)')cmax
       call wtstr(.4,.96,title,1,0,0)
c      call ezvec(avx,avy,mx,my)
c      call velvct(avx,mx,avy,mx,mx,my,0.1*cmax,0.,0,100,0,spv)
        call vvinit(avx,mx,avy,mx,dummy,0,mx,my,dummy,0)
       call vvsetr('vrl',0.20)
       call vvectr(avx,avy,dummy,dummy,dummy,dummy)
      endif
c
c     make constant latitude circles
c
      dd=degrees/float(mx2-1)
      fmax=0.
      do 110 j=1,my
      do 110 i=1,mx
         dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
          work(i,j)=90.-dlat*dd
          fmax=amax1(fmax,work(i,j))
  110 continue
c
c     ILAB=1
      call conrec(work,mx,mx,my,60.,90.,10.,0,-1,-1012)
c
c      output data to ascii file if necessary
c
       if(write_dat)then
        write(8)time,avx,avy
c       do 122 j=1,my
c       do 122 i=1,mx
c           write(8,*)avx(i,j),avy(i,j)
c 122   continue 
      endif
      return
      end
c
c     **************************************************************
c
       subroutine cappot(chrg,pott,nx,ny,nz,ngrd,m,radstrt,
     +             re_equiv,v_equiv,b_equiv,time,write_dat,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      this subroutine will try to make potential drop
c         over auroral oval, vx,vy,vz, assumed to
c         be the inductive electric field 
c      Answer is in kV :DOES BOTH HEMISPHERES AT ONCE to save work
c      charge is the density over a smaple region around
c       the earth 
c
      common /space/charge(31,31,31),poten(31,31,31),
     +              pot(61,61),clat(61,61) 
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
c
       dimension chrg(nx,ny,nz),pott(nx,ny,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       character*4 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       logical write_dat
c
c     for no line labeling set ILAB  to zero
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
c
      ILAB=0
c
c      dimension for plotted array
c
       mx=61
       my=61
       my2=my/2+1
       mx2=mx/2+1
       amx2=mx2-1.
c
       msx=31
       msy=31
       msz=31
       ijk=(msx-1)/2+1
c
c     re_equiv is the physical distance of a grid unit in Re's
c      theta_range is the latitudes for the polar plot and is set
c                    at 35 degrees
c       theta_equiv converts latitude at the earth surface to
c                   latiude at radstrt
c
c      re_equiv=0.84
       theta_equiv=sqrt(re_equiv*radstrt)
       theta_range=0.6108652
       degrees=57.3*theta_range
       del_theta=theta_range/float(mx2-1)
c
c      b_equiv=65.75
c       B is in nT and v in km/s so total SI conversion is 1e-6
c       v_equiv=1e-3
c       d is still in kilometers so the 
c        potential is in kilovolts
c
       d_equiv=6371.*re_equiv
       scale=(1.e-6)*b_equiv*v_equiv*d_equiv
c
      delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
      dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
      delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
      ncx=1.-grd_xmin(m)/delx
      ncy=1.-grd_ymin(m)/dely
      ncz=1.-grd_zmin(m)/delz
c
c     find the charge density equal to the div of VxB
c
      do 10 ks=1,msz
       k=(ks-ijk)+ncz
       do 10 js=1,msy
        j=(js-ijk)+ncy
        do 10 is=1,msx
         i=(is-ijk)+ncx
         charge(is,js,ks)=chrg(i,j,k)
         poten(is,js,ks)=pott(i,j,k)
   10 continue
c
c      initialize work array
c
       do 200 mm=1,2
        iside=(-1)**(mm-1)
       do 20 j=1,my
       do 20 i=1,mx
         pot(i,j)=0.0
   20 continue
c
       do 50 j=1,my
       do 50 i=1,mx
c
c         find equivalent latitude
c
           dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
           dlat=amax1(dlat,0.0000001)
           alat=dlat*del_theta*theta_equiv
           if(alat.gt.1.55)goto 50
           cost=cos(alat)
           sint=sin(alat)
c
c         find equivalent longitude
c
           cosp=(i-mx2)/dlat
           sinp=(j-my2)/dlat
c
c          find position on grid
c
           z1=iside*(radstrt*cost)
           x1=radstrt*sint*cosp
c
c       dipole space to real space
c
           ax=x1*cos_tilt+z1*sin_tilt+xdip
           az=-x1*sin_tilt+z1*cos_tilt+zdip
           ay=(radstrt*sint*sinp+ydip)
           ar=sqrt((ax-xdip)**2+(ay-ydip)**2+(az-zdip)**2)
     +                             +0.0000001
c
c          interpolate data to grid point
c
        ak=1.+(az-grd_zmin(m))/delz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        aj=1.+(ay-grd_ymin(m))/dely
        j1=aj
        j2=j1+1
        dy=aj-j1
c
        ai=1.+(ax-grd_xmin(m))/delx
        i1=ai
        i2=i1+1
        dx=ai-i1
c
        apot=chrg(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +chrg(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +chrg(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +chrg(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +chrg(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +chrg(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +chrg(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +chrg(i2,j2,k2)*(dx)*(dy)*(dz)
c
        pot(i,j)=-apot
c
   50 continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      if(iside.gt.0) title= 'nth cap pot'
      if(iside.le.0) title= 'sth cap pot'
      call wtstr(.5,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      ncon=21
      fmax=pot(1,1)
      fmin=fmax
      do 147 j=1,my
      do 147 i=1,mx
        fmax=amax1(fmax,pot(i,j))
        fmin=amin1(fmin,pot(i,j))
 147  continue
c
      if (fmin.ge.0.0)then 
        cmin=1.05*fmin
      else 
         cmin=0.95*fmin
      endif 
c
      if(fmax.ge.0.0) then
        cmax=0.95*fmax
      else
        cmax=1.05*fmax
      endif
      finc=(cmax-cmin)/float(ncon-1)
      write(title,'(f7.2)')fmin
      title='fmin'//title
      call wtstr(.1,.98,title,1,0,0)
      write(title,'(f7.2)')fmax
      title='fmax'//title
      call wtstr(.25,.98,title,1,0,0)
      call gsplci(1)
      call conrec(pot,mx,mx,my,cmin,cmax,finc,0,-1,-1012)
c
c     make constant latitude circles
c
      dd=degrees/float(mx2-1)
      fmax=0.
      do 150 j=1,my
      do 150 i=1,mx
         dlat=sqrt(1.*(i-mx2)**2+1.*(j-my2)**2)
          clat(i,j)=90.-dlat*dd
          fmax=amax1(fmax,clat(i,j))
  150 continue
c
c     ILAB=1
      call conrec(clat,mx,mx,my,60.,90.,10.,0,-1,-1012)
  200 continue
c
c
c      output data to bin file if necessary
c
       if(write_dat)then
         write(9)time,scale,cos_tilt,sin_tilt,radstrt,
     +     b_equiv,v_equiv,re_equiv,rx
         write(9)charge
       endif
c      ascii write
c       do 160 j=1,my
c       do 160 i=1,mx
c           write(8,*)pot(i,j)
c160    continue 
c      endif
      return
      end
c
c     **************************************************************
c
       subroutine concraft_fix(stuff,cross,nx,ny,nz,m,
     +       xcraft,ncraft, re_equiv,time,label,start,alo,ahi,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot cross-plane quantities at the
c       spacecraft position
c       percent - percentage level of max value for isosurface
c        xcraft is the position of the spacecraft : assumed to
c                  be in simulation units
c        ncraft is the number of spacecraft to plot
c
c     dimension of work array show be ny-2,nz-2
c          (do not plot edge arrays)
      logical start
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       real xrays(2),yrays(2)
       dimension xcraft(4,ncraft),stuff(nx,ny,nz),cross(ny,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       character*4 wd1,wd2,wd3
       character*8 label
       character*20 title
c
c      dimension for plotted array
c
       my=ny
       mz=nz
c
c     set color table 
c
      call sflush
      call isoclrs
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
      ncon=13
      xmin=grd_xmin(m)
      xmax=grd_xmax(m)
      ymin=grd_ymin(m)
      ymax=grd_ymax(m)
      zmin=grd_zmin(m)
      zmax=grd_zmax(m)
      delx=(xmax-xmin)/(nx-1.)
      dely=(ymax-ymin)/(ny-1.)
      delz=(zmax-zmin)/(nz-1.)
      
c
      do 450 n=ncraft,2,-1
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         ai=1.+(ax-xmin)/delx
         aj=1.+(ay-ymin)/dely
         ak=1.+(az-zmin)/delz
         if( (ax.lt.xmin).or.(ax.gt.xmax).or.
     +       (ay.lt.ymin).or.(ay.gt.ymax).or.
     +       (az.lt.zmin).or.(az.gt.zmax) )goto 450
c
         i1=ai
         i2=ai+1
         dx=ai-i1
         ddx=1.-dx
         fmin=0.
         fmax=0.
          do 410 k=1,nz
          do 410 j=1,ny
            cross(j,k)=stuff(i1,j,k)*ddx+
     +                       stuff(i2,j,k)*dx
            fmin=amin1(fmin,cross(j,k))
            fmax=amax1(fmax,cross(j,k))
  410   continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      write(title,'(f7.3)')time
      title='UT = '//title
      call wtstr(.7,.975,title,2,0,0)
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.15,.98,title,1,0,0)
      write(title,'(f7.4)')fmax
      call wtstr(.3,.98,title,1,0,0)
      title='fmax'//title
c
      cmin=alo
      cmax=ahi
      clev=(cmax-cmin)/(ncon+1.)
      if(.not.start) call cnrccf(cross,my,my,mz,cmin,
     +             cmax,clev,0,-1,-1012,2.5,0,1)
      IRECMN=18
c     call conrec(cross,my,my,mz,cmin,
c    +             cmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
        call gsplci(16)
         nl=11
         n2=(nl-1)/2
        do nn=1,nl
          ns=(nn-n2)/2
          shift=ns*.025
          xrays(1)=aj-.5
          xrays(2)=aj+.5
          yrays(1)=ak+shift
          yrays(2)=ak+shift
          call curve(xrays,yrays,2)
          xrays(1)=aj+shift
          xrays(2)=aj+shift
          yrays(1)=ak+.5
          yrays(2)=ak-.5
        call curve(xrays,yrays,2)
        enddo
  450 continue
c
      return
      end
c
c     **************************************************************
c 
       subroutine conalong_fix(stuff,cross,nx,ny,nz,m,
     +        xcraft,ncraft,re_equiv,time,label,start,alo,ahi,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot X-Z quantities at the
c       spacecraft position
c       percent - percentage level of max value for isosurface
c        xcraft is the position of the spacecraft : assumed to
c                  be in simulation units
c        ncraft is the number of spacecraft to plot
c
      logical start
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       real xrays(2),yrays(2)
       dimension xcraft(4,ncraft),stuff(nx,ny,nz),cross(nx,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       character*4 wd1,wd2,wd3
       character*8 label
       character*20 title
c
c      dimension for plotted array
c
       my=nx
       mz=nz
c
c     set color table
c
      call sflush
      call isoclrs
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
      ncon=13
      xmin=grd_xmin(m)
      xmax=grd_xmax(m)
      ymin=grd_ymin(m)
      ymax=grd_ymax(m)
      zmin=grd_zmin(m)
      zmax=grd_zmax(m)
      delx=(xmax-xmin)/(nx-1.)
      dely=(ymax-ymin)/(ny-1.)
      delz=(zmax-zmin)/(nz-1.)

c
      do 450 n=ncraft,2,-1
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         ai=1.+(ax-xmin)/delx
         aj=1.+(ay-ymin)/dely
         ak=1.+(az-zmin)/delz
         if( (ax.lt.xmin).or.(ax.gt.xmax).or.
     +       (ay.lt.ymin).or.(ay.gt.ymax).or.
     +       (az.lt.zmin).or.(az.gt.zmax) )goto 450
c
         j1=aj
         j2=aj+1
         dy=aj-j1
         ddy=1.-dy
         fmin=0.
         fmax=0.
          do 410 k=1,nz
          do 410 i=1,nx
            cross(i,k)=stuff(i,j1,k)*ddy+
     +                       stuff(i,j2,k)*dy
            fmin=amin1(fmin,cross(i,k))
            fmax=amax1(fmax,cross(i,k))
  410   continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      write(title,'(f7.3)')time
      title='UT = '//title
      call wtstr(.7,.975,title,2,0,0)
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.15,.98,title,1,0,0)
      write(title,'(f7.4)')fmax
      call wtstr(.3,.98,title,1,0,0)
      title='fmax'//title
c
      cmin=alo
      cmax=ahi
      clev=(cmax-cmin)/(ncon+1.)
      if(.not.start) call cnrccf(cross,my,my,mz,cmin,
     +             cmax,clev,0,-1,-1012,2.5,0,1)
c     IRECMN=18
c     call conrec(cross,my,my,mz,cmin,
c    +             cmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
        call gsplci(16)
         nl=11
         n2=(nl-1)/2
        do nn=1,nl
          ns=(nn-n2)/2
          shift=ns*.025
          xrays(1)=ai-.5
          xrays(2)=ai+.5
          yrays(1)=ak+shift
          yrays(2)=ak+shift
          call curve(xrays,yrays,2)
          xrays(1)=ai+shift
          xrays(2)=ai+shift
          yrays(1)=ak+.5
          yrays(2)=ak-.5
        call curve(xrays,yrays,2)
        enddo
  450 continue
c
      return
      end  
c
c     **************************************************************
c 
       subroutine conplane_fix(stuff,cross,nx,ny,nz,m,
     +      xcraft,ncraft,re_equiv,time,label,start,alo,ahi,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot X-Y quantities at the
c       spacecraft position
c       percent - percentage level of max value for isosurface
c        xcraft is the position of the spacecraft : assumed to
c                  be in simulation units
c        ncraft is the number of spacecraft to plot
c
      logical start
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       real xrays(2),yrays(2)
       dimension xcraft(4,ncraft),stuff(nx,ny,nz),cross(nx,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       character*4 wd1,wd2,wd3
       character*8 label
       character*20 title
c
c      dimension for plotted array
c
       my=nx
       mz=ny
c
c     set color table
c
      call sflush
      call isoclrs
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
      ncon=13
      xmin=grd_xmin(m)
      xmax=grd_xmax(m)
      ymin=grd_ymin(m)
      ymax=grd_ymax(m)
      zmin=grd_zmin(m)
      zmax=grd_zmax(m)
      delx=(xmax-xmin)/(nx-1.)
      dely=(ymax-ymin)/(ny-1.)
      delz=(zmax-zmin)/(nz-1.)

c
      do 450 n=ncraft,2,-1
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         ai=1.+(ax-xmin)/delx
         aj=1.+(ay-ymin)/dely
         ak=1.+(az-zmin)/delz
         if( (ax.lt.xmin).or.(ax.gt.xmax).or.
     +       (ay.lt.ymin).or.(ay.gt.ymax).or.
     +       (az.lt.zmin).or.(az.gt.zmax) )goto 450
c
         k1=ak
         k2=ak+1
         dz=ak-k1
         ddz=1.-dz
         fmin=0.
         fmax=0.
          do 410 j=1,ny
          do 410 i=1,nx
            cross(i,j)=stuff(i,j,k1)*ddz+
     +                       stuff(i,j,k2)*dz
            fmin=amin1(fmin,cross(i,j))
            fmax=amax1(fmax,cross(i,j))
  410   continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      write(title,'(f7.3)')time
      title='UT = '//title
      call wtstr(.7,.975,title,2,0,0)
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.15,.98,title,1,0,0)
      write(title,'(f7.4)')fmax
      call wtstr(.3,.98,title,1,0,0)
      title='fmax'//title
c
      cmin=alo
      cmax=ahi
      clev=(cmax-cmin)/(ncon+1.)
      if(.not.start) call cnrccf(cross,my,my,mz,cmin,
     +             cmax,clev,0,-1,-1012,2.5,0,1)
c     IRECMN=18
c     call conrec(cross,my,my,mz,cmin,
c    +             cmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
        call gsplci(16)
         nl=11
         n2=(nl-1)/2
        do nn=1,nl
          ns=(nn-n2)/2
          shift=ns*.025
          xrays(1)=ai-.5
          xrays(2)=ai+.5
          yrays(1)=aj+shift
          yrays(2)=aj+shift
          call curve(xrays,yrays,2)
          xrays(1)=ai+shift
          xrays(2)=ai+shift
          yrays(1)=aj+.5
          yrays(2)=aj-.5
        call curve(xrays,yrays,2)
        enddo
  450 continue
c
      return
      end  
c
c     **************************************************************
c
       subroutine concraft(stuff,cross,nx,ny,nz,m,
     +            xcraft,ncraft,re_equiv,time,label,start,frac,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot cross-plane quantities at the
c       spacecraft position
c       percent - percentage level of max value for isosurface
c        xcraft is the position of the spacecraft : assumed to
c                  be in simulation units
c        ncraft is the number of spacecraft to plot
c
c     dimension of work array show be ny-2,nz-2
c          (do not plot edge arrays)
      logical start
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       real xrays(2),yrays(2)
       dimension xcraft(4,ncraft),stuff(nx,ny,nz),cross(ny,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       character*4 wd1,wd2,wd3
       character*8 label
       character*20 title
c
c      dimension for plotted array
c
       my=ny
       mz=nz
c
c     set color table 
c
      call sflush
      call isoclrs
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
      ncon=13
      xmin=grd_xmin(m)
      xmax=grd_xmax(m)
      ymin=grd_ymin(m)
      ymax=grd_ymax(m)
      zmin=grd_zmin(m)
      zmax=grd_zmax(m)
      delx=(xmax-xmin)/(nx-1.)
      dely=(ymax-ymin)/(ny-1.)
      delz=(zmax-zmin)/(nz-1.)
      
c
      do 450 n=ncraft,2,-1
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         ai=1.+(ax-xmin)/delx
         aj=1.+(ay-ymin)/dely
         ak=1.+(az-zmin)/delz
         if( (ax.lt.xmin).or.(ax.gt.xmax).or.
     +       (ay.lt.ymin).or.(ay.gt.ymax).or.
     +       (az.lt.zmin).or.(az.gt.zmax) )goto 450
c
         i1=ai
         i2=ai+1
         dx=ai-i1
         ddx=1.-dx
         fmin=0.
         fmax=0.
          do 410 k=1,nz
          do 410 j=1,ny
            cross(j,k)=stuff(i1,j,k)*ddx+
     +                       stuff(i2,j,k)*dx
            fmin=amin1(fmin,cross(j,k))
            fmax=amax1(fmax,cross(j,k))
  410   continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      write(title,'(f7.3)')time
      title='UT = '//title
      call wtstr(.7,.975,title,2,0,0)
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.15,.98,title,1,0,0)
      write(title,'(f7.4)')fmax
      call wtstr(.3,.98,title,1,0,0)
      title='fmax'//title
      if(fmin*fmax.lt.0.)then
        cmax=amax1(fmax,abs(fmin))
        cmin=-cmax
      else
        cmax=fmax/frac
        cmin=fmin/frac
      endif
      clev=(cmax-cmin)/(ncon+1.)
      if(.not.start) call cnrccf(cross,my,my,mz,cmin,
     +             cmax,clev,0,-1,-1012,2.5,0,1)
      IRECMN=18
c     call conrec(cross,my,my,mz,cmin,
c    +             cmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
        call gsplci(16)
         nl=11
         n2=(nl-1)/2
        do nn=1,nl
          ns=(nn-n2)/2
          shift=ns*.025
          xrays(1)=aj-.5
          xrays(2)=aj+.5
          yrays(1)=ak+shift
          yrays(2)=ak+shift
          call curve(xrays,yrays,2)
          xrays(1)=aj+shift
          xrays(2)=aj+shift
          yrays(1)=ak+.5
          yrays(2)=ak-.5
        call curve(xrays,yrays,2)
        enddo
  450 continue
c
      return
      end
c
c     **************************************************************
c 
       subroutine conalong(stuff,cross,nx,ny,nz,m,
     +         xcraft,ncraft,re_equiv,time,label,start,frac,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot X-Z quantities at the
c       spacecraft position
c       percent - percentage level of max value for isosurface
c        xcraft is the position of the spacecraft : assumed to
c                  be in simulation units
c        ncraft is the number of spacecraft to plot
c
      logical start
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       real xrays(2),yrays(2)
       dimension xcraft(4,ncraft),stuff(nx,ny,nz),cross(nx,nz) 	
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       character*4 wd1,wd2,wd3
       character*8 label
       character*20 title
c
c      dimension for plotted array
c
       my=nx
       mz=nz
c
c     set color table
c
      call sflush
      call isoclrs
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
      ncon=13
      xmin=grd_xmin(m)
      xmax=grd_xmax(m)
      ymin=grd_ymin(m)
      ymax=grd_ymax(m)
      zmin=grd_zmin(m)
      zmax=grd_zmax(m)
      delx=(xmax-xmin)/(nx-1.)
      dely=(ymax-ymin)/(ny-1.)
      delz=(zmax-zmin)/(nz-1.)

c
      do 450 n=ncraft,2,-1
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         ai=1.+(ax-xmin)/delx
         aj=1.+(ay-ymin)/dely
         ak=1.+(az-zmin)/delz
         if( (ax.lt.xmin).or.(ax.gt.xmax).or.
     +       (ay.lt.ymin).or.(ay.gt.ymax).or.
     +       (az.lt.zmin).or.(az.gt.zmax) )goto 450
c
         j1=aj
         j2=aj+1
         dy=aj-j1
         ddy=1.-dy
         fmin=0.
         fmax=0.
          do 410 k=1,nz
          do 410 i=1,nx
            cross(i,k)=stuff(i,j1,k)*ddy+
     +                       stuff(i,j2,k)*dy
            fmin=amin1(fmin,cross(i,k))
            fmax=amax1(fmax,cross(i,k))
  410   continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      write(title,'(f7.3)')time
      title='UT = '//title
      call wtstr(.7,.975,title,2,0,0)
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.15,.98,title,1,0,0)
      write(title,'(f7.4)')fmax
      call wtstr(.3,.98,title,1,0,0)
      title='fmax'//title
      if(fmin*fmax.lt.0.)then
        cmax=amax1(fmax,abs(fmin))
        cmin=-cmax
      else
        cmax=fmax
        cmin=fmin
      endif
      cmin=cmin/frac
      cmax=cmax/frac
      clev=(cmax-cmin)/(ncon+1.)
      if(.not.start) call cnrccf(cross,my,my,mz,cmin,
     +             cmax,clev,0,-1,-1012,2.5,0,1)
c     IRECMN=18
c     call conrec(cross,my,my,mz,cmin,
c    +             cmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
        call gsplci(16)
         nl=11
         n2=(nl-1)/2
        do nn=1,nl
          ns=(nn-n2)/2
          shift=ns*.025
          xrays(1)=ai-.5
          xrays(2)=ai+.5
          yrays(1)=ak+shift
          yrays(2)=ak+shift
          call curve(xrays,yrays,2)
          xrays(1)=ai+shift
          xrays(2)=ai+shift
          yrays(1)=ak+.5
          yrays(2)=ak-.5
        call curve(xrays,yrays,2)
        enddo
  450 continue
c
      return
      end  
c
c     **************************************************************
c 
       subroutine conplane(stuff,cross,nx,ny,nz,m,
     +       xcraft,ncraft,re_equiv,time,label,start,frac,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot X-Y quantities at the
c       spacecraft position
c       percent - percentage level of max value for isosurface
c        xcraft is the position of the spacecraft : assumed to
c                  be in simulation units
c        ncraft is the number of spacecraft to plot
c
      logical start
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       real xrays(2),yrays(2)
       dimension xcraft(4,ncraft),stuff(nx,ny,nz),cross(nx,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       character*4 wd1,wd2,wd3
       character*8 label
       character*20 title
c
c      dimension for plotted array
c
       my=nx
       mz=ny
c
c     set color table
c
      call sflush
      call isoclrs
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
      ncon=13
      xmin=grd_xmin(m)
      xmax=grd_xmax(m)
      ymin=grd_ymin(m)
      ymax=grd_ymax(m)
      zmin=grd_zmin(m)
      zmax=grd_zmax(m)
      delx=(xmax-xmin)/(nx-1.)
      dely=(ymax-ymin)/(ny-1.)
      delz=(zmax-zmin)/(nz-1.)

c
      do 450 n=ncraft,2,-1
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         ai=1.+(ax-xmin)/delx
         aj=1.+(ay-ymin)/dely
         ak=1.+(az-zmin)/delz
         if( (ax.lt.xmin).or.(ax.gt.xmax).or.
     +       (ay.lt.ymin).or.(ay.gt.ymax).or.
     +       (az.lt.zmin).or.(az.gt.zmax) )goto 450
c
         k1=ak
         k2=ak+1
         dz=ak-k1
         ddz=1.-dz
         fmin=0.
         fmax=0.
          do 410 j=1,ny
          do 410 i=1,nx
            cross(i,j)=stuff(i,j,k1)*ddz+
     +                       stuff(i,j,k2)*dz
            fmin=amin1(fmin,cross(i,j))
            fmax=amax1(fmax,cross(i,j))
  410   continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      write(title,'(f7.3)')time
      title='UT = '//title
      call wtstr(.7,.975,title,2,0,0)
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.4)')fmin
      title='fmin'//title
      call wtstr(.15,.98,title,1,0,0)
      write(title,'(f7.4)')fmax
      call wtstr(.3,.98,title,1,0,0)
      title='fmax'//title
      if(fmin*fmax.lt.0.)then
        cmax=amax1(fmax,abs(fmin))
        cmin=-cmax
      else
        cmax=fmax
        cmin=fmin
      endif
      cmin=cmin/frac
      cmax=cmax/frac
      clev=(cmax-cmin)/(ncon+1.)
      if(.not.start) call cnrccf(cross,my,my,mz,cmin,
     +             cmax,clev,0,-1,-1012,2.5,0,1)
c     IRECMN=18
c     call conrec(cross,my,my,mz,cmin,
c    +             cmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
        call gsplci(16)
         nl=11
         n2=(nl-1)/2
        do nn=1,nl
          ns=(nn-n2)/2
          shift=ns*.025
          xrays(1)=ai-.5
          xrays(2)=ai+.5
          yrays(1)=aj+shift
          yrays(2)=aj+shift
          call curve(xrays,yrays,2)
          xrays(1)=ai+shift
          xrays(2)=ai+shift
          yrays(1)=aj+.5
          yrays(2)=aj-.5
        call curve(xrays,yrays,2)
        enddo
  450 continue
c
      return
      end  
c
c     **************************************************************
c
       subroutine contrace(stuff,bx,by,bz,nx,ny,nz,ngrd,m,
     +            xmin,xmax,ymin,ymax,zmin,zmax,iside,
     +            time,label,nlevs,ncon,add_dip,
     +            radstrt,rearth,nphi,theta1,theta2,ncuts,
     +            t,tt,t3,t2,work,mx,my,mz,muvwp2,mz2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
       common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
       real t(mx,my,mz),tt(mx,my,mz),t3(mx,my,mz),t2(mx,my,mz2),
     +     work(muvwp2,muvwp2) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       real xray(1000),yray(1000),zray(1000)
       dimension stuff(nx,ny,nz,ngrd),
     +                     bx(nx,ny,nz),by(nx,ny,nz),
     +                     bz(nx,ny,nz)
       real eye(3),tlev(6),tcon(14)
       character*4 llbs(14),wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(14)
       logical add_dip,roc
c
       my2=my/2+1
       z22=1.3*mz2
       maxpts=1000
c
c     set color table 
c
      call sflush
      call isoclrs
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-xdip-.00001)
       aymax=amin1(ymax,grd_ymax(m)-ydip-.00001)
       azmax=amin1(zmax,grd_zmax(m)-zdip-.00001)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
       ddx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
       ddy=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
       ddz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      load T stuff
c
       do 30 k=1,mz
        az=iside*(zmin+delz*(k-1))
        ak=1.+(az-grd_zmin(m))/ddz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        do 20 j=1,my
         ay=iside*(ymin+dely*(j-1))
         aj=1.+(ay-grd_ymin(m))/ddy
         j1=aj
         j2=j1+1
         dy=aj-j1
c
c
         do 10 i=1,mx
          ax=xmin+delx*(i-1)
          ai=1.+(ax-grd_xmin(m))/ddx
          i1=ai
          i2=i1+1
          dx=ai-i1
c
          t(i,j,k)=stuff(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +stuff(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +stuff(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +stuff(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +stuff(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +stuff(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +stuff(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +stuff(i2,j2,k2,m)*(dx)*(dy)*(dz)
c
          radius=sqrt(ax**2+ay**2+az**2)
          tt(i,j,k)=radius
c
   10     continue
   20   continue
   30 continue
c
c      find max and minimum values in array t
c
      tmi=t(1,1,1)
      tma=t(1,1,1)
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      dlev=(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=(tma-tmi)/(ncon+1.)
      ampl=(abs(tma)+abs(tmi))/2.
      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=tmi+dcon*n
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)/ampl
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c     muvwp2=amax1(mx*1.,my*1.,mz*1.)+2
c
c     ***************************************
c       HALF PLANE ONLY START AT ZDIP
c
c
c     zero subset array tt
c
   
      do 100 k=1,mz2
      do 100 j=1,my
      do 100 i=1,mx
       t2(i,j,k)=0.
  100 continue
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=-iside*my2*5.
      eye(3)=mz2*3.5

c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.2,.975,label,2,0,0)
       if(iside.ge.0)then
           title='North-Dusk'
        else
           title='South-Dawn'
        endif
      call wtstr(.5,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zdip
      title='y axis'
      call wtstr(.93,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')zdip
      title='x axis'
      call wtstr(.18,.6,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.16,.55,title,1,0,0)
c
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      do 110 j=1,my
       do 105 i=1,mx
       t2(i,j,k)=t(i,j,mz2)
  105 continue
  110 continue
c
c     draw contours in x-y plane
c
      do 115 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my,my,mz2,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  115 continue
c
c     place the earth and map it out
c
      do 125 k=1,mz2
      do 125 j=1,my
       do 120 i=1,mx
       t2(i,j,k)=tt(i,j,mz2+k-1)
  120 continue
  125 continue
      call gsplci(2)
      tisom=rearth
      call isosrf(t2,mx,mx,my,my,mz2,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c         loading x-z plane
c
c     j=my2
c     do 130 k=1,mz
c     do 130 i=1,mx
c      t2(i,j,k)=t(i,j,k)
c 130 continue
c
c     draw contours in x-y plane
c
c     do 135 n=1,ncon
c     call gselnt(0)
c     call sflush
c     tisom=tcon(n)
c     call gsplci(n+1)
c     call isosrf(t2,mx,mx,my2,my2,mz,eye,muvwp2,work,tisom,2,
c    &   vpl,vpr,vpb,vpt)
c 135 continue
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz2
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c     set up ray trace initial points
c
      dphi=6.283185/float(nphi)
      deltheta=(theta2-theta1)/float(ncuts)
       if(iside.gt.0)then
          rzmin=zdip
          rzmax=azmax
        else
          rzmin=-azmax
          rzmax=zdip
        endif
c
      do 180 mm=1,ncuts
       theta=theta1+deltheta*(mm-1)
       sint=sin(theta)
       cost=cos(theta)
       ncol=15-2*(mm-1)
       mcol=5+2*(mm-1)
c
       do 160 n=1,nphi
        phi=dphi*(n-1)
        cosp=cos(phi)
        sinp=sin(phi)
c
        x1=radstrt*sint*cosp
        yi=iside*(radstrt*sint*sinp+ydip)
        z1=iside*(radstrt*cost)
c
c       dipole space to real space
c
         xi=x1*cos_tilt+z1*sin_tilt+xdip
         zi=-x1*sin_tilt+z1*cos_tilt+zdip
c
        dir=-delx
        call rungem(bx,by,bz,nx,ny,nz,m,ddx,
     +      xi,yi,zi,xmin,xmax,ymin,ymax,rzmin,rzmax,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +     grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
         do 140 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray(nn)=1.+(xray(nn)-xmin)/delx
         yray(nn)=1.+(iside*yray(nn)-ymin)/dely
         zray(nn)=1.+iside*(zray(nn)-zdip)/delz
  140   continue
c
c       make color choice and plot the grap
c
         call sflush
         call gsplci(ncol)
         call curve3(xray,yray,zray,npts)
c
        dir=delx
        call rungem(bx,by,bz,nx,ny,nz,m,ddx,
     +      xi,yi,zi,xmin,xmax,ymin,ymax,rzmin,rzmax,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
         do 150 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray(nn)=1.+(xray(nn)-xmin)/delx
         yray(nn)=1.+(iside*yray(nn)-ymin)/dely
         zray(nn)=1.+iside*(zray(nn)-zdip)/delz
  150   continue
c
c       make color choice and plot the grap
c
         call sflush
         call gsplci(mcol)
         call curve3(xray,yray,zray,npts)
c
  160  continue
  180 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
c
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=-iside*my*2.5
      eye(3)=mz2*3.5
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.2,.975,label,2,0,0)
       if(iside.ge.0)then
           title='North-Dusk'
        else
           title='South-Dawn'
        endif
      call wtstr(.5,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.98,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.95,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
c     write(wd1,'(f4.0)')axmax
c     write(wd2,'(f4.0)')aymin
c     write(wd3,'(f4.0)')zmin
c     title='x axis'
c     call wtstr(.05,.6,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.03,.55,title,1,0,0)
c
      call gsplci(2)
      tisom=rearth
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c
c     zero subset array tt
c
      do 200 k=1,mz
      do 200 j=1,my
      do 200 i=1,mx
       t3(i,j,k)=0.
  200 continue
c
c     load data ------ right hand side
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=mz2
      do 215 j=1,my
       do 210 i=1,mx
       t3(i,j,k)=t(i,j,k)
  210 continue
  215 continue
c
c     draw contours in x-y plane
c
      do 220 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t3,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  220 continue
c
c    draw axes lines 
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
c     call line3(x1,y1,z22,x2,y1,z22)
c     call line3(x1,y1,z22,x1,y2,z22)
c     call line3(x1,y1,z22,x1,y1,z2)
c     call line3(x1,y2,z22,x2,y2,z22)
c     call line3(x2,y1,z22,x2,y2,z22)
      call sflush
c
      do 280 mm=1,ncuts
       theta=theta1+deltheta*(mm-1)
       sint=sin(theta)
       cost=cos(theta)
       ncol=15-2*(mm-1)
       mcol=5+2*(mm-1)
c
       do 260 n=1,nphi
        phi=dphi*(n-1)
        cosp=cos(phi)
        sinp=sin(phi)
c
        x1=radstrt*sint*cosp
        yi=iside*(radstrt*sint*sinp+ydip)
        z1=iside*(radstrt*cost)
c
c       dipole space to real space
c
         xi=x1*cos_tilt+z1*sin_tilt+xdip
         zi=-x1*sin_tilt+z1*cos_tilt+zdip
c
        dir=-delx
        call rungem(bx,by,bz,nx,ny,nz,m,ddx,
     +      xi,yi,zi,xmin,xmax,ymin,ymax,-zmax,zmax,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
         do 240 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray(nn)=1.+(xray(nn)-xmin)/delx
         yray(nn)=1.+(iside*yray(nn)-ymin)/dely
         zray(nn)=1.+(iside*zray(nn)-zmin)/delz
  240   continue
c
c       make color choice and plot the grap
c
         call sflush
         call gsplci(ncol)
         call curve3(xray,yray,zray,npts)
c
        dir=+delx
        call rungem(bx,by,bz,nx,ny,nz,m,ddx,
     +      xi,yi,zi,xmin,xmax,ymin,ymax,-zmax,zmax,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
         do 250 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray(nn)=1.+(xray(nn)-xmin)/delx
         yray(nn)=1.+(iside*yray(nn)-ymin)/dely
         zray(nn)=1.+(iside*zray(nn)-zmin)/delz
  250   continue
c
c       make color choice and plot the grap
c
         call sflush
         call gsplci(mcol)
         call curve3(xray,yray,zray,npts)
c
  260  continue
  280 continue
  290 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
      return
      end
c
c      *****************************************
c
      subroutine rungea(bx,by,bz,press,rho,nx,ny,nz,
     +    m,xi,yi,zi,xmin,xmax,ymin,ymax,
     +    zmin,zmax,add_dip,ergies,rhod,maxpts,dir,
     +    delx,dely,delz,rearth,ngrd,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c     this routine uses a fourth order runge-kutta method
c         to trace  stream functions of current and magnetic fld
c         xi,yi,zi, and find maximum temperature along them
c
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
      dimension bx(nx,ny,nz),by(nx,ny,nz),bz(nx,ny,nz),
     +           press(nx,ny,nz),rho(nx,ny,nz) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
      real xray(1000),yray(1000),zray(1000)
c
       logical add_dip,roc
c
       maxpts=1000
c
       tstep=0.25*dir
c
       xray(1)=xi
       yray(1)=yi
       zray(1)=zi       
c
       ts6=tstep/6.
       do 10 n=2,maxpts
c
c           step 1
c
       ax=xray(n-1)
       ay=yray(n-1)
       az=zray(n-1)
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx1,dy1,dz1,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 2
c
       ax=xray(n-1)+tstep*0.5*dx1
       ay=yray(n-1)+tstep*0.5*dy1
       az=zray(n-1)+tstep*0.5*dz1
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx2,dy2,dz2,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 3
c
       ax=xray(n-1)+tstep*0.5*dx2
       ay=yray(n-1)+tstep*0.5*dy2
       az=zray(n-1)+tstep*0.5*dz2
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx3,dy3,dz3,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 4
c
       ax=xray(n-1)+tstep*dx3
       ay=yray(n-1)+tstep*dy3
       az=zray(n-1)+tstep*dz3
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx4,dy4,dz4,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c       update new position and wavevector
c
      xray(n)=xray(n-1)+ts6*(dx1+2.*dx2+2.*dx3+dx4)
      yray(n)=yray(n-1)+ts6*(dy1+2.*dy2+2.*dy3+dy4)
      zray(n)=zray(n-1)+ts6*(dz1+2.*dz2+2.*dz3+dz4)
c
c    find energy at the point
c
        ax=xray(n)
        ay=yray(n)
        az=zray(n)
c
c          interpolate data to grid point
c
        ak=1.+(az-grd_zmin(m))/delz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        aj=1.+(ay-grd_ymin(m))/dely
        j1=aj
        j2=j1+1
        dy=aj-j1
c
        ai=1.+(ax-grd_xmin(m))/delx
        i1=ai
        i2=i1+1
        dx=ai-i1
c
        aerg=press(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +press(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +press(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +press(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +press(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +press(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +press(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +press(i2,j2,k2)*(dx)*(dy)*(dz)
        arho=rho(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +rho(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +rho(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +rho(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +rho(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +rho(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +rho(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +rho(i2,j2,k2)*(dx)*(dy)*(dz)

c 
         aergd=aerg/arho
         arho=amax1(arho,0.0001)
c
         ergies=amax1(aergd,ergies)
         rhod=amin1(arho,rhod)
c
c       test to see if ray is within selected region
c
         ar=sqrt((xray(n)-xdip)**2+(yray(n)-ydip)**2
     +                          +(zray(n)-zdip)**2)
         radius=sqrt((xray(n)-xray(1))**2+(yray(n)-yray(1))**2
     +                +(zray(n)-zray(1))**2)
         if((xray(n).lt.xmin).or.(xray(n).gt.xmax).or.
     +   (yray(n).lt.ymin).or.(yray(n).gt.ymax).or.
     +   (zray(n).lt.zmin).or.(zray(n).gt.zmax).or.
     +   (ar.lt.rearth+1.).or.(radius.gt.4.*rearth).or.(roc)) return
c
   10 continue
c
        return
        end
cc
c      *****************************************
c
      subroutine rungeb(efldx,efldy,efldz,bx,by,bz,nx,ny,nz,
     +    ngrd,m,rx,xi,yi,zi,xmin,xmax,ymin,ymax,
     +    zmin,zmax,add_dip,potential,maxpts,dir,rearth,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c     this routine uses a fourth order runge-kutta method
c         to trace  stream functions of current and magnetic fld
c         xi,yi,zi, and integrates the field aligned potential drop
c
      dimension bx(nx,ny,nz),by(nx,ny,nz),bz(nx,ny,nz),
     +          efldx(nx,ny,nz),efldy(nx,ny,nz),efldz(nx,ny,nz)
      real xray(1000),yray(1000),zray(1000)
      dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       logical add_dip,roc
c
       rx2=rx*3.
       potential=0.
       maxpts=1000
       delx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
       dely=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
       delz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
       tstep=0.25*dir
c
       xray(1)=xi
       yray(1)=yi
       zray(1)=zi       
c
       ts6=tstep/6.
       do n=2,maxpts
c
c           step 1
c
       ax=xray(n-1)
       ay=yray(n-1)
       az=zray(n-1)
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx1,dy1,dz1,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 2
c
       ax=xray(n-1)+tstep*0.5*dx1
       ay=yray(n-1)+tstep*0.5*dy1
       az=zray(n-1)+tstep*0.5*dz1
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx2,dy2,dz2,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 3
c
       ax=xray(n-1)+tstep*0.5*dx2
       ay=yray(n-1)+tstep*0.5*dy2
       az=zray(n-1)+tstep*0.5*dz2
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx3,dy3,dz3,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 4
c
       ax=xray(n-1)+tstep*dx3
       ay=yray(n-1)+tstep*dy3
       az=zray(n-1)+tstep*dz3
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +            AX,AY,AZ,dx4,dy4,dz4,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c       update new position and wavevector
c
      xray(n)=xray(n-1)+ts6*(dx1+2.*dx2+2.*dx3+dx4)
      yray(n)=yray(n-1)+ts6*(dy1+2.*dy2+2.*dy3+dy4)
      zray(n)=zray(n-1)+ts6*(dz1+2.*dz2+2.*dz3+dz4)
c
c      define integral limits
c
        xi=xray(n-1)
        yi=yray(n-1)
        zi=zray(n-1)
c
        xf=xray(n)
        yf=yray(n)
        zf=zray(n)
c
c          interpolate data to grid point
c
        ax=(xf+xi)/2.
        ay=(yf+yi)/2.
        az=(zf+zi)/2.
c
        ak=1.+(az-grd_zmin(m))/delz
        k1=ak
        k2=k1+1
        dz=ak-k1
        ddz=1.-dz
c
        aj=1.+(ay-grd_ymin(m))/dely
        j1=aj
        j2=j1+1
        dy=aj-j1
        ddy=1.-dy
c
        ai=1.+(ax-grd_xmin(m))/delx
        i1=ai
        i2=i1+1
        dx=ai-i1
        ddx=1.-dx
c
        aex=  efldx(i1,j1,k1)*ddx*ddy*ddz
     +       +efldx(i1,j1,k2)*ddx*ddy*dz
     +       +efldx(i1,j2,k1)*ddx*dy*ddz
     +       +efldx(i1,j2,k2)*ddx*dy*dz
     +       +efldx(i2,j1,k1)*dx*ddy*ddz
     +       +efldx(i2,j1,k2)*dx*ddy*dz
     +       +efldx(i2,j2,k1)*dx*dy*ddz
     +       +efldx(i2,j2,k2)*dx*dy*dz
        aey=  efldy(i1,j1,k1)*ddx*ddy*ddz
     +       +efldy(i1,j1,k2)*ddx*ddy*dz
     +       +efldy(i1,j2,k1)*ddx*dy*ddz
     +       +efldy(i1,j2,k2)*ddx*dy*dz
     +       +efldy(i2,j1,k1)*dx*ddy*ddz
     +       +efldy(i2,j1,k2)*dx*ddy*dz
     +       +efldy(i2,j2,k1)*dx*dy*ddz
     +       +efldy(i2,j2,k2)*dx*dy*dz
        aez=  efldz(i1,j1,k1)*ddx*ddy*ddz
     +       +efldz(i1,j1,k2)*ddx*ddy*dz
     +       +efldz(i1,j2,k1)*ddx*dy*ddz
     +       +efldz(i1,j2,k2)*ddx*dy*dz
     +       +efldz(i2,j1,k1)*dx*ddy*ddz
     +       +efldz(i2,j1,k2)*dx*ddy*dz
     +       +efldz(i2,j2,k1)*dx*dy*ddz
     +       +efldz(i2,j2,k2)*dx*dy*dz
c
         drx=xf-xi
         dry=yf-yi
         drz=zf-zi
c
         potential=potential+drx*aex+dry*aey+drz*aez
c
c       test to see if ray is within selected region
c
         ar=sqrt(xray(n)**2+yray(n)**2 +zray(n)**2)

         radius=sqrt((xray(n)-xray(1))**2+(yray(n)-yray(1))**2
     +                +(zray(n)-zray(1))**2)
         if((xray(n).lt.xmin).or.(xray(n).gt.xmax).or.
     +   (yray(n).lt.ymin).or.(yray(n).gt.ymax).or.
     +   (zray(n).lt.zmin).or.(zray(n).gt.zmax).or.
     +   (ar.lt.rearth+rx2).or.(radius.gt.3.*rearth)
     +   .or.(roc)) return
c
        enddo
c
        return
        end
c
c      *****************************************
c
      subroutine rungem(bx,by,bz,nx,ny,nz,m,rx,
     +     xi,yi,zi,xmin,xmax,ymin,ymax,zmin,zmax,rearth,
     +     add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +     grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c     this routine uses a fourth order runge-kutta method
c         to trace to trace stream functions of current and magnetic fld
c         xi,yi,zi, until it hits boundary or maximum number
c         points is reach
c
      dimension bx(nx,ny,nz),by(nx,ny,nz),bz(nx,ny,nz)
      dimension  xray(maxpts),yray(maxpts),zray(maxpts) 
      dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

c
       logical add_dip,roc
c
c      maxpts=1000
c
       tstep=0.1*dir
c
       xray(1)=xi
       yray(1)=yi
       zray(1)=zi       
c
       ts6=tstep/6.
       do 10 n=2,maxpts
c
c           step 1
c
       ax=xray(n-1)
       ay=yray(n-1)
       az=zray(n-1)
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx1,dy1,dz1,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 2
c
       ax=xray(n-1)+tstep*0.5*dx1
       ay=yray(n-1)+tstep*0.5*dy1
       az=zray(n-1)+tstep*0.5*dz1
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx2,dy2,dz2,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 3
c
       ax=xray(n-1)+tstep*0.5*dx2
       ay=yray(n-1)+tstep*0.5*dy2
       az=zray(n-1)+tstep*0.5*dz2
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx3,dy3,dz3,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        step 4
c
       ax=xray(n-1)+tstep*dx3
       ay=yray(n-1)+tstep*dy3
       az=zray(n-1)+tstep*dz3
       call INTPOL(bx,by,bz,nx,ny,nz,m,add_dip,
     +             AX,AY,AZ,dx4,dy4,dz4,1.,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c       update new position and wavevector
c
      npts=n
      xray(n)=xray(n-1)+ts6*(dx1+2.*dx2+2.*dx3+dx4)
      yray(n)=yray(n-1)+ts6*(dy1+2.*dy2+2.*dy3+dy4)
      zray(n)=zray(n-1)+ts6*(dz1+2.*dz2+2.*dz3+dz4)
c
c       test to see if ray is within selected region
c
         ar=sqrt(xray(n)**2+yray(n) **2+zray(n)**2)
         if((xray(n).lt.xmin).or.(xray(n).gt.xmax).or.
     +   (yray(n).lt.ymin).or.(yray(n).gt.ymax).or.
     +   (zray(n).lt.zmin).or.(zray(n).gt.zmax).or.
     +    (ar.lt.rearth+1.5*rx).or.(roc)) goto 20
c
   10 continue
        return
   20 npts=npts-1
        return
        end
c
c     **********************************************
c
      SUBROUTINE TRACE(bx,by,bz,n1,n2,n3,m,add_dip,
     +         XI,YI,ZI,DIR,NP,XF,YF,ZF,XX,YY,ZZ,
     +         XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX,L,rearth,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)

c
c    3 field line tracing subroutines originally by Tsyganenko.
c    Modified to trace field lines of Bx,By,Bz (nx,ny,nz)
C
C   TRACES FIELD LINE FROM ARBITRARY POINT OF SPACE UP TO THE EARTH
C   SURFACE OR UP TO MODEL LIMITING BOUNDARY.
C-------------- INPUT PARAMETERS:
C   XI,YI,ZI - GSM COORDS OF INITIAL POINT (IN EARTH RADII),
C   DIR - SIGN OF TRACING DIRECTION: IF DIR=1. THEN ANTIPARALLEL TO
C     B VECTOR (E.G. FROM NORTHERN TO SOUTHERN CONJUGATE POINT),
C     AND IF DIR=-1. THEN PARALLEL TO B.
C   NP - UPPER ESTIMATE OF NUMBER OF STEPS ALONG THE FIELD LINE
C     (OF THE ORDER OF SEVERAL HUNDREDS).
C-------------- OUTPUT PARAMETERS:
C   XF,YF,ZF - GSM COORDS OF FINAL POINT
C   XX,YY,ZZ - ARRAYS (LENGTH NP) CONTAINING COORDS OF FIELD LINE POINTS
C   L - ACTUAL NUMBER OF FIELD LINE POINTS. IF L EXCEEDS NP, TRACING
C     TERMINATES, AND A WARNING IS DISPLAYED
C
C
C                   AUTHOR: NIKOLAI A. TSYGANENKO
C                           INSTITUTE OF PHYSICS
C                           ST.-PETERSBURG STATE UNIVERSITY
C                           STARY PETERGOF 198904
C                           ST.-PETERSBURG
C                           RUSSIA
C
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
      dimension bx(n1,n2,n3),by(n1,n2,n3),bz(n1,n2,n3),
     +         XX(NP),YY(NP),ZZ(NP) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

      logical ROC,add_dip
c
      err=0.05
c     DS=0.5*DIR
      X=XI
      Y=YI
      Z=ZI
      DS=DIR
      DS3=DS/3.
      L=0
c
      CALL INTPOL(bx,by,bz,n1,n2,n3,m,add_dip,
     +           X,Y,Z,R1,R2,R3,DS3,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
       if(ROC) return
c
      DO 1 L=1,NP
        XX(L)=X
        YY(L)=Y
        ZZ(L)=Z
c
         CALL STEP(bx,by,bz,n1,n2,n3,m,add_dip,X,Y,Z,DS,ERR,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
         ar=sqrt((X-xdip)**2+(Y-ydip)**2+(Z-zdip)**2)
         if((x.lt.xmin).or.(x.gt.xmax).or.
     +   (y.lt.ymin).or.(y.gt.ymax).or.
     +   (z.lt.zmin).or.(z.gt.zmax).or.
     +    (ar.lt.rearth+1.)) goto 8
  1   continue
c
c     not enough points
c
c     write(6,10)
        L=L-1
      RETURN
c
c last point
c
  8   XF=X
      YF=Y
      ZF=Z
      XX(L)=X
      YY(L)=Y
      ZZ(L)=Z 
    
c10     FORMAT(//,1X,'**** COMPUTATIONS IN THE SUBROUTINE TRACE',
c     + ' ARE TERMINATED: NP IS TOO SMALL ****'//)
       ERR=0.0005

      RETURN
      END
c***************************************************************
C
      SUBROUTINE STEP(bx,by,bz,n1,n2,n3,m,add_dip,X,Y,Z,DS,ERRIN,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
C
C     RE-CALCULATES COORDS X,Y,Z FOR ONE STEP ALONG FIELD LINE. 
C     DS IS STEP SIZE,
C     ERRIN IS PERMISSIBLE ERROR VALUE, 
c
       dimension bx(n1,n2,n3),by(n1,n2,n3),bz(n1,n2,n3) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       logical ROC,add_dip
c
  1   DS3=-DS/3.
      CALL INTPOL(bx,by,bz,n1,n2,n3,m,add_dip,
     +          X,Y,Z,R11,R12,R13,DS3,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
          if(ROC) return
      CALL INTPOL(bx,by,bz,n1,n2,n3,m,add_dip,
     +         X+R11,Y+R12,Z+R13,R21,R22,R23,DS3,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
      CALL INTPOL(bx,by,bz,n1,n2,n3,m,add_dip,
     +        X+.5*(R11+R21),Y+.5*(R12+R22),Z+.5*
     +       (R13+R23),R31,R32,R33,DS3,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
      CALL INTPOL(bx,by,bz,n1,n2,n3,m,add_dip,
     +       X+.375*(R11+3.*R31),Y+.375*(R12+3.*R32
     +       ),Z+.375*(R13+3.*R33),R41,R42,R43,DS3,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
      CALL INTPOL(bx,by,bz,n1,n2,n3,m,add_dip,
     +        X+1.5*(R11-3.*R31+4.*R41),Y+1.5*(R12-
     +     3.*R32+4.*R42),Z+1.5*(R13-3.*R33+4.*R43),
     +       R51,R52,R53,DS3,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
      ERRCUR=ABS(R11-4.5*R31+4.*R41-.5*R51)+ABS(R12-4.5*R32+4.*R42-.5*
     *R52)+ABS(R13-4.5*R33+4.*R43-.5*R53)
      IF (ERRCUR.LT.ERRIN) GOTO 2
      DS=DS*.5
      if (ds.lt.0.2)goto 2
      GOTO 1
  2   X=X+.5*(R11+4.*R41+R51)
      Y=Y+.5*(R12+4.*R42+R52)
      Z=Z+.5*(R13+4.*R43+R53)
      IF(ERRCUR.LT.ERRIN*.04.AND.ABS(DS).LT.1.33) DS=DS*1.5
      RETURN
      END
c
c     ***********************************************
c
      SUBROUTINE INTPOL(bx,by,bz,n1,n2,n3,m,add_dip,
     +                   AX,AY,AZ,R1,R2,R3,DS3,ROC,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c     interpolate the magnetic to from nearest grid points
c     to the actual point ax,ay,az and then calculates the
c     direction for the increments in R1,R2,R3
c
       dimension bx(n1,n2,n3),by(n1,n2,n3),bz(n1,n2,n3) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       logical ROC,add_dip
c
c       altered to make plots below equator assuming symmetry
c

       ddx=(grd_xmax(m)-grd_xmin(m))/(n1-1.)
       ddy=(grd_ymax(m)-grd_ymin(m))/(n2-1.)
       ddz=(grd_zmax(m)-grd_zmin(m))/(n3-1.)
c
        ak=1.+(az-grd_zmin(m))/ddz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
         aj=1.+(ay-grd_ymin(m))/ddy
         j1=aj
         j2=j1+1
         dy=aj-j1
c
         ai=1.+(ax-grd_xmin(m))/ddx
         i1=ai
         i2=i1+1
         dx=ai-i1
c
        abx=0.
        aby=0.
        abz=0.
c
        if(add_dip)call dipole(abx,aby,abz,ax,ay,az)
c
        abx=abx+bx(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +bx(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +bx(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +bx(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +bx(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +bx(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +bx(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +bx(i2,j2,k2)*(dx)*(dy)*(dz)
c
        aby=aby+by(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +by(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +by(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +by(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +by(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +by(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +by(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +by(i2,j2,k2)*(dx)*(dy)*(dz)
c
        abz=abz+bz(i1,j1,k1)*(1. - dx)*(1. - dy)*(1. - dz)
     +       +bz(i1,j1,k2)*(1. - dx)*(1. - dy)*(dz)
     +       +bz(i1,j2,k1)*(1. - dx)*(dy)*(1. - dz)
     +       +bz(i1,j2,k2)*(1. - dx)*(dy)*(dz)
     +       +bz(i2,j1,k1)*(dx)*(1. - dy)*(1. - dz)
     +       +bz(i2,j1,k2)*(dx)*(1. - dy)*(dz)
     +       +bz(i2,j2,k1)*(dx)*(dy)*(1. - dz)
     +       +bz(i2,j2,k2)*(dx)*(dy)*(dz)
c
      sqb=sqrt(abx**2+aby**2+abz**2)
      if(sqb.lt.1.e-4) then
        ROC=.true.
       return
      endif
c
      ROC=.false.
      B=DS3/sqb
      R1=abx*B
      R2=aby*B
      R3=abz*B 
c    
      RETURN
      END  
c
c     **************************************************************
c
       subroutine vct3d(vx,vy,vz,nx,ny,nz,m,xmin,xmax,ymin,
     +           ymax,zmin,zmax,time,label,iv,strtch,rearth,
     +            t,tx,ty,tz,work,mx,my,mz,muvwp2,mz2,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c     plots 3-D vector field - iv sets velocity direction for
c           color changes in arrows
c
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0
c
       real t(mx,my,mz),tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz),
     +     work(muvwp2,muvwp2) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       dimension vx(nx,ny,nz),vy(nx,ny,nz),vz(nx,ny,nz)
       real eye(3)
       integer vpl,vpr,vpb,vpt
       character*4 wd1,wd2,wd3
       character*8 label
       character*15 title
c      
c      dimension for plotted array

       my2=my/2+1
c
c      effective step size between points - slight less than
c         unity to ensure arrows do not go out of bounds
c
      hi=.99
      hj=.99
      hk=.99
c
c     al = length of arrow in xy-plane
c     stretch= enlargement of arrows
c
      al=0.6*hi
      al2=0.2
      stretch=2.0*strtch
      vmin=0.00001
c 
c      angle of arrow
c
      beta=30./180.*3.1415926
c
c     set viewport size
c
c     full screen would be vpl=1 (left) vpr=32760 (right)
c                         vpb=1 (bottom) vpt=32760 (top)
c     drawing lines over the top using set33 with 
c                xa,xb,ya,yb set to the percentage fraction
c                of these numbers
c 
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.00001)
       aymax=amin1(ymax,grd_ymax(m)-.00001)
       azmax=amin1(zmax,grd_zmax(m)-.00001)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
       delx=amin1(delx,dely,delz)
       dely=amin1(delx,dely,delz)
       delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      NOTE delx,dely,delz used to convert real space to a position
c        on grid with
c         x_grid = 1 +(x_real-xmin)/delx
c                OR
c         x_real = xmin + (x_grid -1.)*delx
c
c     BACK VIEW -------------
c
c     initialize eye position
c
      eye(1)=mx*5.
      eye(2)=my*4.
      eye(3)=mz*4.
c
c     plot earth
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
c     set color table
c
       call sflush
       call isoclrs
c
      call wtstr(.4,.975,label,2,0,0)
      title='back view'
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
      write(title,'(1pe9.2)')vm
      title='magn '//title
      call wtstr(.5,.95,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')azmax
      title='x axis'
      call wtstr(.2,.25,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.2,.2,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.6,.92,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.6,.89,title,1,0,0)
c
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.95,.87,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.92,.82,title,1,0,0)
c
      call gselnt(0)
      call sflush
c
c      load T stuff to position earth and find max vector
c
       vm=0.
        ddx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
        ddy=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
        ddz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
       do  k=1,mz
        az=zmin+(k-1.)*delz
        do  j=1,my
         ay=ymin+(j-1.)*dely
         do  i=1,mx
          ax=xmin+(i-1.)*delx
c
          radius=sqrt((ax-xdip)**2+(ay-ydip)**2
     +                +(az-zdip)**2)
          t(i,j,k)=radius
c
        enddo
       enddo
       enddo
c
c     plot earth and grid references
c
      call gsplci(2)
      tisom=rearth
      call isosrf(t,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c     determine vector field
c
c
       vm=0
       do k=1,mz
        az=zmin+(k-1.)*delz
        ak=1.+(az-grd_zmin(m))/ddz
        k1=ak
        k2=k1+1
        dz=ak-k1
c
        do j=1,my
c
         ay=ymin+(j-1.)*dely
         aj=1.+(ay-grd_ymin(m))/ddy
         j1=aj
         j2=j1+1
         dy=aj-j1
c
         do i=1,mx
          ax=xmin+(i-1.)*delx
          ai=1.+(ax-grd_xmin(m))/ddx
          i1=ai
          i2=i1+1
          dx=ai-i1
c
          tx(i,j,k)=vx(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +vx(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +vx(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +vx(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +vx(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +vx(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +vx(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +vx(i2,j2,k2)*(dx)*(dy)*(dz)
c
          ty(i,j,k)=vy(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +vy(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +vy(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +vy(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +vy(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +vy(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +vy(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +vy(i2,j2,k2)*(dx)*(dy)*(dz)
c
          tz(i,j,k)=vz(i1,j1,k1)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +vz(i1,j1,k2)*(1.-dx)*(1.-dy)*(dz)
     +            +vz(i1,j2,k1)*(1.-dx)*(dy)*(1.-dz)
     +            +vz(i1,j2,k2)*(1.-dx)*(dy)*(dz)
     +            +vz(i2,j1,k1)*(dx)*(1.-dy)*(1.-dz)
     +            +vz(i2,j1,k2)*(dx)*(1.-dy)*(dz)
     +            +vz(i2,j2,k1)*(dx)*(dy)*(1.-dz)
     +            +vz(i2,j2,k2)*(dx)*(dy)*(dz)
c
          vm=amax1(vm,abs(tx(i,j,k)),abs(ty(i,j,k)),abs(tz(i,j,k)))
          radius=sqrt((ax-xdip)**2+(ay-ydip)**2
     +                +(az-zdip)**2)

          if(radius.lt.rearth+1.)then
            tx(i,j,k)=0.
            ty(i,j,k)=0.
            tz(i,j,k)=0.
          endif
c
         enddo
         enddo
        enddo
c
      vm=amax1(vm,0.00004)      
c
c     draw points
c
      ncol=3
      ncol1=13
      jskip=4
      iskip=2
      do 180 k=1,mz-5,2
       z1=k*hk+0.05
       do 180 j=jskip/2,my,jskip
         y1=j*hj+0.05
         jcol=5+2*(j/jskip)
         do 180 i=1,mx,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 180
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=iskip*hj*ty(i,j,k)/vm
         dz=iskip*hk*tz(i,j,k)/vm
c
         x2=x1+stretch*dx
         y2=y1+stretch*dy
         z2=z1+stretch*dz
c
         call sflush
c
         call gsplci(jcol)
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 180
c
c      draw arrows - set color for arror heads 
c
         call sflush
         if(iv.eq.1)then
           if(dx.ge.0.0)call gsplci(ncol)
           if(dx.lt.0.0)call gsplci(ncol1)
         else if(iv.eq.2)then
           if(dy.ge.0.0)call gsplci(ncol)
           if(dy.lt.0.0)call gsplci(ncol1)
         else
           if(dz.ge.0.0)call gsplci(ncol)
           if(dz.lt.0.0)call gsplci(ncol1)
         endif
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  180 continue
c
c     FRONT VIEW -------------
c
c     initialize eye position
c
      eye(1)=-mx*5.
      eye(2)=my*4.
      eye(3)=mz*4.
c
c     plot earth
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.4,.975,label,2,0,0)
      title='front view'
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
      write(title,'(1pe8.1)')vm
      title='magnit '//title
      call wtstr(.5,.95,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.22,.3,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.2,.25,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='bck pos'
      call wtstr(.6,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.6,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.95,.8,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.92,.75,title,1,0,0)
c
      call gselnt(0)
      call sflush
c
c     plot earth and grid references
c
      call gsplci(2)
      tisom=rearth
      call isosrf(t,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c
c     draw points
c
      ncol=3
      ncol1=13
      jskip=4
      iskip=2
      do 280 k=1,mz-5,2
       z1=k*hk+0.05
       do 280 j=jskip/2,my,jskip
         y1=j*hj+0.05
         jcol=5+2*(j/jskip)
         do 280 i=1,mx,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 280
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=iskip*hj*ty(i,j,k)/vm
         dz=iskip*hk*tz(i,j,k)/vm
c
         x2=x1+stretch*dx
         y2=y1+stretch*dy
         z2=z1+stretch*dz
         call sflush
         call gsplci(jcol)
c
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 280
c
c      draw arrows
c
c
         call sflush
         if(iv.eq.1)then
           if(dx.ge.0.0)call gsplci(ncol)
           if(dx.lt.0.0)call gsplci(ncol1)
         else if(iv.eq.2)then
           if(dy.ge.0.0)call gsplci(ncol)
           if(dy.lt.0.0)call gsplci(ncol1)
         else
           if(dz.ge.0.0)call gsplci(ncol)
           if(dz.lt.0.0)call gsplci(ncol1)
         endif
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  280 continue
c
c     TOP VIEW
c
c
c     initialize eye position
c
      eye(1)=mx/6
      eye(2)=my*4.
      eye(3)=mz*4.
c
c     plot earth
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.4,.975,label,2,0,0)
      title='top-dawn view'
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
      write(title,'(1pe8.1)')vm
      title='magnit '//title
      call wtstr(.5,.95,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')zmin
      title='x axis'
      call wtstr(.22,.8,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.2,.75,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='yaxis'
      call wtstr(.95,.3,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.92,.25,title,1,0,0)
c
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.9,.92,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.88,title,1,0,0)
c
      call gselnt(0)
      call sflush
c
c     plot earth and grid references
c
      call gsplci(2)
      tisom=rearth
      call isosrf(t,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c
c     draw points
c
      ncol=3
      ncol1=13
      jskip=4
      iskip=2
      do 380 k=1,mz-5,2
       z1=k*hk+0.05
       do 380 j=jskip/2,my,jskip
         y1=j*hj+0.05
         jcol=5+2*(j/jskip)
         do 380 i=1,mx,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 380
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=iskip*hj*ty(i,j,k)/vm
         dz=iskip*hk*tz(i,j,k)/vm
c
         x2=x1+stretch*dx
         y2=y1+stretch*dy
         z2=z1+stretch*dz
         call sflush
         call gsplci(jcol)
c
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 380
c
c      draw arrows
c
        call sflush
c
         if(iv.eq.1)then
           if(dx.ge.0.0)call gsplci(ncol)
           if(dx.lt.0.0)call gsplci(ncol1)
         else if(iv.eq.2)then
           if(dy.ge.0.0)call gsplci(ncol)
           if(dy.lt.0.0)call gsplci(ncol1)
         else
           if(dz.ge.0.0)call gsplci(ncol)
           if(dz.lt.0.0)call gsplci(ncol1)
         endif
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  380 continue
c
c     TOP VIEW -DUSK SIDE
c
c
c     initialize eye position
c
      eye(1)=mx/6
      eye(2)=-my*4.
      eye(3)=mz*4.
c
c     plot earth
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.4,.975,label,2,0,0)
      title='top-dusk view'
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
      write(title,'(1pe8.1)')vm
      title='magnit '//title
      call wtstr(.5,.95,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.22,.8,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.2,.75,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')zmin
      title='xaxis'
      call wtstr(.95,.3,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.92,.25,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')azmax
      title='back top'
      call wtstr(.9,.92,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.88,title,1,0,0)
c
      call gselnt(0)
      call sflush
c
c     plot earth and grid references
c
      call gsplci(2)
      tisom=rearth
      call isosrf(t,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c
c     draw points
c
      ncol=3
      ncol1=13
      jskip=4
      iskip=2
      do 480 k=1,mz-5,2
       z1=k*hk+0.05
       do 480 j=jskip/2,my,jskip
         y1=j*hj+0.05
         jcol=5+2*(j/jskip)
         do 480 i=1,mx,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 480
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=iskip*hj*ty(i,j,k)/vm
         dz=iskip*hk*tz(i,j,k)/vm
c
         x2=x1+stretch*dx
         y2=y1+stretch*dy
         z2=z1+stretch*dz
         call sflush
         call  gsplci(jcol)
c
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 480
c
c      draw arrows
c
        call sflush
c
         if(iv.eq.1)then
           if(dx.ge.0.0)call gsplci(ncol)
           if(dx.lt.0.0)call gsplci(ncol1)
         else if(iv.eq.2)then
           if(dy.ge.0.0)call gsplci(ncol)
           if(dy.lt.0.0)call gsplci(ncol1)
         else
           if(dz.ge.0.0)call gsplci(ncol)
           if(dz.lt.0.0)call gsplci(ncol1)
         endif
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  480 continue
      return
      end
c
c     ***********************************************
c
      subroutine arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
c
c     calculate relative positions of two points to draw arrows
c        input: dx,dy  -- vector
c           al - length  of arrow
c           beta - angle of arrow
c     output: (adx1,ady1), (adx2,ady2)  -- two relative positions
c
         data pih,pi,pi32,pi2/1.57079,3.14159,4.71239,6.28318/     
c
c       determine angle of the vector
c
        if(abs(dx).le.0.00001) then
             theta=pih
           if(dy.lt.0.)  theta=pi32
        else if (abs(dy).lt.0.00001) then
              theta=0.
           if(dx.lt.0.) theta=pi
        else
             theta=atan(abs(dy/dx))
              if(dx.lt.0..and.dy.gt.0.) then
                 theta=pi-theta
              else if(dx.lt.0..and.dy.lt.0.) then
                 theta=pi+theta
               else if(dx.gt.0..and.dy.lt.0.) then
                 theta=pi2-theta
               endif
         endif
c
c      calculate the relative position of two points
c
        alfa1=theta-beta
        alfa2=pih-theta-beta
        adx1=-al*cos(alfa1)
        ady1=-al*sin(alfa1)
        adx2=-al*sin(alfa2)
        ady2=-al*cos(alfa2)     
c
        return
         end
c
c
c     **************************************************************
c
       subroutine contur(stuff,nx,ny,nz,ngrd,m,xmin,xmax,
     +       ymin,ymax,zmin,zmax,time,label,nlevs,ncon,rearth,
     +       t,tt,t2,work,mx,my,mz,mz2,muvwp2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
c
       dimension t(mx,my,mz),tt(mx,my,mz2),t2(mx,my,mz2),
     +    work(muvwp2,muvwp2) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       dimension stuff(nx,ny,nz,ngrd)
c
       real eye(3),tlev(6),tcon(14)
       character*4 llbs(14),wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(14)
c
c      dimension for plotted array
c
       my2=my/2+1
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.00001)
       aymax=amin1(ymax,grd_ymax(m)-.00001)
       azmax=amin1(zmax,grd_zmax(m)-.00001)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
        ddx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
        ddy=(grd_ymax(m)-grd_ymin(m))/(ny-1.)
        ddz=(grd_zmax(m)-grd_zmin(m))/(nz-1.)
c
c      load T stuff
c
       do 30 k=1,mz
        az=zmin+delz*(k-1)
        ak=1.+(az-grd_zmin(m))/ddz
        k1=ak
        k2=k1+1
        dz=ak-k1
        do 20 j=1,my
         ay=ymin+dely*(j-1)
         aj=1.+(ay-grd_ymin(m))/ddy
         j1=aj
         j2=j1+1
         dy=aj-j1
c
         do 10 i=1,mx
          ax=xmin+delx*(i-1)
          ai=1.+(ax-grd_xmin(m))/ddx
          i1=ai
          i2=i1+1
          dx=ai-i1
c
c
          t(i,j,k)=stuff(i1,j1,k1,m)*(1.-dx)*(1.-dy)*(1.-dz)
     +            +stuff(i1,j1,k2,m)*(1.-dx)*(1.-dy)*(dz)
     +            +stuff(i1,j2,k1,m)*(1.-dx)*(dy)*(1.-dz)
     +            +stuff(i1,j2,k2,m)*(1.-dx)*(dy)*(dz)
     +            +stuff(i2,j1,k1,m)*(dx)*(1.-dy)*(1.-dz)
     +            +stuff(i2,j1,k2,m)*(dx)*(1.-dy)*(dz)
     +            +stuff(i2,j2,k1,m)*(dx)*(dy)*(1.-dz)
     +            +stuff(i2,j2,k2,m)*(dx)*(dy)*(dz)
c
          radius=sqrt(ax**2+ay**2+az**2)
          tt(i,j,k)=radius

   10     continue
   20   continue
   30 continue
c
c      find max and minimum values in array t
c
      tmi=t(1,1,1)
      tma=t(1,1,1)
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      alim=0.5
      dlev=alim*(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=alim*(tma-tmi)/(ncon+1.)
      ampl=(abs(tma)+abs(tmi))/2.
      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=tmi+dcon*n
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)/ampl
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c     ****************************************
c          make multiple surface plots
c     ****************************************
c
c     a view from behind
c     ------------------
c
c     initialize eye position
c
      eye(1)=mx*5.
      eye(2)=my*4.
      eye(3)=mz*4.

c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
c     set color table 
c
      call sflush
      call isoclrs
c
      title=' : back view'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')azmax
      title='x axis'
      call wtstr(.2,.25,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.2,.2,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.6,.92,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.6,.89,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.95,.87,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.92,.82,title,1,0,0)
c
c     draw desired isosurfaces -- I hope
c
      do 70 n=1,nlevs
      call gselnt(0)
      call sflush
      tisom=tlev(n)
      ncol=n*(dlev/dcon)
      call gsplci(ncol)
      call isosrf(t,mx,mx,my,my,mz,eye,muvwp2,work,tisom,3,
     &   vpl,vpr,vpb,vpt)
   70 continue
c
c
c     plot earth and grid references
c
      call gsplci(2)
      tisom=rearth
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
c
c
c     a view from infront
c     -------------------
c
c     initialize eye position
c
      eye(1)=-mx*5.
      eye(2)=my*4.
      eye(3)=mz*4.

c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : front view'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.22,.3,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.2,.25,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='bck pos'
      call wtstr(.6,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.6,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.95,.8,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.92,.75,title,1,0,0)
c
c     draw desired isosurfaces -- I hope
c
      do 80 n=1,nlevs
      call gselnt(0)
      call sflush
      tisom=tlev(n)
      ncol=n*(dlev/dcon)
      call gsplci(ncol)
      call isosrf(t,mx,mx,my,my,mz,eye,muvwp2,work,tisom,3,
     &   vpl,vpr,vpb,vpt)
   80 continue
c
c     plot earth and grid references
c
      call gsplci(2)
      tisom=rearth
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
c
c
c     a view from the side and top
c     ----------------------------
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=my*4.
      eye(3)=mz*4.

c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : side view'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')zmin
      title='x axis'
      call wtstr(.22,.8,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.2,.75,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='yaxis'
      call wtstr(.95,.3,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.92,.25,title,1,0,0)
c
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.9,.92,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.88,title,1,0,0)
c
c     draw desired isosurfaces -- I hope
c
      do 90 n=1,nlevs
      call gselnt(0)
      call sflush
      tisom=tlev(n)
      ncol=n*(dlev/dcon)
      call gsplci(ncol)
      call isosrf(t,mx,mx,my,my,mz,eye,muvwp2,work,tisom,3,
     &   vpl,vpr,vpb,vpt)
   90 continue
c
c     plot earth and grid references
c
      call gsplci(2)
      tisom=rearth
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
c
c     ***************************************
c       make contour plots down the middle
c
      my2=my/2+1
      aymin=(ymin+aymax)/2.
c
c     zero subset array tt
c
   
      do 100 k=1,mz
      do 100 j=1,my2
      do 100 i=1,mx
       t2(i,j,k)=0.
  100 continue
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=-my2*5.
      eye(3)=mz*3.5

c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : DUSK NOON'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.93,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')zmin
      title='x axis'
      call wtstr(.18,.6,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.16,.55,title,1,0,0)
c
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      do 115 j=1,my2
       do 110 i=1,mx
       t2(i,j,k)=t(i,j,k)
  110 continue
  115 continue
c
c     draw contours in x-y plane
c
      do 140 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my2,my2,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  140 continue
c
c     re-zero tt
c
      k=1
      do 125 j=1,my2
       do 120 i=1,mx
       t2(i,j,k)=0.
  120 continue
  125 continue
c
c         loading x-z plane
c
      j=my2
      do 130 k=1,mz
      do 130 i=1,mx
       t2(i,j,k)=t(i,j,k)
  130 continue
c
c     draw contours in x-y plane
c
      do 135 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my2,my2,mz,eye,muvwp2,work,tisom,2,
     &   vpl,vpr,vpb,vpt)
  135 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
c
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=-10.
      eye(3)=mz*8.
c
c     zero subset array tt
c

      do 200 k=1,mz
      do 200 j=1,my
      do 200 i=1,mx
       tt(i,j,k)=0.
  200 continue
c     do 200 k=1,mz
c     do 200 j=1,my2
c     do 200 i=1,mx
c      t2(i,j,k)=0.
c 200 continue
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : dawn dusk'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='t = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.98,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.95,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')zmin
      title='x axis'
      call wtstr(.05,.6,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.03,.55,title,1,0,0)
c
c     load data ------ right hand side
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      do 215 j=1,my
       do 210 i=1,mx
       tt(i,j,k)=t(i,j,k)
  210 continue
  215 continue
c
c     draw contours in x-y plane
c
      do 240 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  240 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
      return
      end
c
c     **************************************************************
c
       subroutine conflow(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +            xmin,xmax,ymin,ymax,zmin,zmax,xcut,
     +            time,label,nlevs,ncon,ivel,strtch,
     +            tx,ty,tz,t,t2,work,mx,my,mz,mz2,muvwp2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
       real stuff(nx,ny,nz,ngrd),vx(nx,ny,nz),
     +                     vy(nx,ny,nz),vz(nx,ny,nz)
       dimension t(mx,my,mz),tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz),
     +    t2(mx,my,mz),work(muvwp2,muvwp2)
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       real eye(3),tlev(6),tcon(14)
       character*4 llbs(14),wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(14)
c
c     skip parameters for field lines and arrows
c      
c      jskip=(ny-1)/40
c      iskip=(nx-1)/40+1
       jskip=3
       iskip=3
c 
c      dimension for plotted array
c
       my2=my/2+1
c
c      effective step size between points - slight less than
c         unity to ensure arrows do not go out of bounds
c
      hi=.99
      hj=.99
      hk=.99
c
c     al = length of arrow in xy-plane
c     stretch= enlargement of arrows
c
      al=0.6*hi
      al2=0.2
      stretch=2.0*strtch
      vmin=0.00001
      vm=0.0
c 
c      angle of arrow
c
      beta=30./180.*3.1415926
c
c     set color table 
c
      call sflush
      call isoclrs
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.00001)
       aymax=amin1(ymax,grd_ymax(m)-.00001)
       azmax=amin1(zmax,grd_zmax(m)-.00001)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      load T stuff
c
      call filldatav(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +        t,t2,tx,ty,tz,mx,my,mz,xmin,ymin,zmin,
     +        delx,dely,delz,vm,grd_xmin,grd_xmax,
     +        grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      find max and minimum values in array t
c
      tmi=0.
      tma=0.
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      dlev=(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=(tma-tmi)/(ncon+1.)
      ampl=(abs(tma)+abs(tmi))/2.+1.e-6
      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=tmi+dcon*n
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)/ampl
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c     ***************************************
c       make contour plots down the middle
c
      my2=my/2+1
      aymin=(ymin+aymax)/2.
c
c     zero subset array tt
c
   
      do 100 k=1,mz
      do 100 j=1,my
      do 100 i=1,mx
       t2(i,j,k)=0.
  100 continue
c
c     initialize eye position
c
c     eye(1)=-mx
c     eye(2)=-my2*2.
c     eye(3)=mz*3.0
c                   
      eye(1)=mx/2
      eye(2)=-my2*2.
      eye(3)=mz2*3.5

c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
      write(title,'(1pe9.2)')vm
      title='vm ='//title
      call wtstr(.7,.935,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.93,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')zmin
      title='x axis'
      call wtstr(.18,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.16,.85,title,1,0,0)
c
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      kk=mz2
      do 110 j=1,my
       do 105 i=1,mx
       t2(i,j,k)=t(i,j,kk)
  105 continue
  110 continue
c
c     draw contours in x-y plane
c
      do 115 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  115 continue
c
c     re-zero tt
c
      k=1
      do 125 j=1,my
       do 120 i=1,mx
       t2(i,j,k)=0.
  120 continue
  125 continue
c
c         loading x-z plane
c
      j=my
      jj=my2
      do 130 k=1,mz
      do 130 i=1,mx
       t2(i,j,k)=t(i,jj,k)
  130 continue
c
c     draw contours in x-y plane
c
      do 132 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,2,
     &   vpl,vpr,vpb,vpt)
  132 continue
c
c     loading y-zplane
c
      do 134  k=1,mz 
      do 134  i=1,mx 
       t2(i,j,k)=0.
  134 continue
      icut=1.+(xcut-xmin)/delx
      i=mx
      do 136 j=1,my
      do 136 k=1,mz
       t2(i,j,k)=t(icut,j,k)
  136 continue
      do 138 n=1,ncon 
      call gselnt(0) 
      call sflush 
      tisom=tcon(n)
      call gsplci(n+1) 
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,4,
     &   vpl,vpr,vpb,vpt) 
  138 continue
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.0,1.,0.0,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
c     call line3(x1,y1,z2,x2,y1,z2)
      call line3(x1,y1,z1,x1,y2,z1)
c     call line3(x1,y1,z2,x1,y2,z2)
c     call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c     draw points - NOON MIDNIGHT Sector
c
      ncol=3
      j=my2
      jj=my
c     iskip=2
      jcol=1
      do 140 k=2,mz-1,2
       z1=k*hk+0.05
       y1=jj*hj-0.05
        
         do 140 i=2,mx-1,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 140
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
c        dy=iskip*hj*ty(i,j,k)/vm
         dy=0.
         dz=iskip*hk*tz(i,j,k)/vm
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(jcol)
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 140
c
c      draw arrows - set color for arror heads 
c
        if((ivel.eq.1).and.(dx.ge.0.0)) call gsplci(15)
        if((ivel.eq.1).and.(dx.lt.0.0)) call gsplci(5) 
        if((ivel.eq.2).and.(dy.ge.0.0)) call gsplci(15) 
        if((ivel.eq.2).and.(dy.lt.0.0)) call gsplci(5) 
        if((ivel.eq.3).and.(dz.ge.0.0)) call gsplci(15) 
        if((ivel.eq.3).and.(dz.lt.0.0)) call gsplci(5) 
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  140 continue
c
c     draw points: Equatorial
c
      ncol=3
      k=mz2
      kk=1
c     jskip=2
c     iskip=2
       z1=kk*hk+0.05
       do 145 j=2,my-1,jskip
         y1=j*hj+0.05
         do 145 i=2,mx-1,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 145
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=iskip*hj*ty(i,j,k)/vm
c        dz=iskip*hk*tz(i,j,k)/vm
         dz=0.
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(1)
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 145
c
c      draw arrows - set color for arror heads 
c
         call sflush
        if(dx.ge.0.0) call gsplci(15) 
        if(dx.lt.0.0) call gsplci(5) 
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  145 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
      return
      end
c
c     **************************************************************
c
       subroutine conhot(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +            xmin,xmax,ymin,ymax,zmin,zmax,xcut,
     +            time,label,nlevs,ncon,ivel,strtch,tlim,
     +            tx,ty,tz,t,t2,work,mx,my,mz,mz2,muvwp2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
c
       real stuff(nx,ny,nz,ngrd),vx(nx,ny,nz),
     +              vy(nx,ny,nz),vz(nx,ny,nz)
       dimension t(mx,my,mz),tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz),
     +    t2(mx,my,mz),work(muvwp2,muvwp2) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)

       real eye(3),tlev(6),tcon(18)
       character*4 llbs(18),wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(18)

c
c     skip parameters for field lines and arrows
c      
c      jskip=(ny-1)/40
c      iskip=(nx-1)/40

       jskip=3
       iskip=3
c
c      dimension for plotted array
c
       my2=my/2+1
c
       t=0.
       t2=0.
       tx=0.
       ty=0.
       tz=0.
c
c      effective step size between points - slight less than
c         unity to ensure arrows do not go out of bounds
c
      hi=.99
      hj=.99
      hk=.99
c
c     al = length of arrow in xy-plane
c     stretch= enlargement of arrows
c
      al=0.6*hi
      al2=0.2
      stretch=2.0*strtch
      vmin=0.00001
      vm=0.0
c 
c      angle of arrow
c
      beta=30./180.*3.1415926
c
c     set color table 
c
      call sflush
      call isoclrs_hot
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.0001)
       aymax=amin1(ymax,grd_ymax(m)-.0001)
       azmax=amin1(zmax,grd_zmax(m)-.0001)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      load T stuff
c
      call filldatav(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +        t,t2,tx,ty,tz,mx,my,mz,xmin,ymin,zmin,
     +         delx,dely,delz,vm, 
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      find max and minimum values in array t
c
      tmi=0.
      tma=0.
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      dlev=(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=(tlim)/(ncon+1.)
      ampl=(abs(tlim))/2.
      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=dcon*n
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)/ampl
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c     ***************************************
c       make contour plots down the middle
c
      my2=my/2+1
      aymin=(ymin+aymax)/2.
c
c     initialize eye position
c
c     eye(1)=-mx
c     eye(2)=-my2*2.
c     eye(3)=mz*3.0
c                   
      eye(1)=mx/2
      eye(2)=-my2*2.
      eye(3)=mz2*3.5

c
c     initialize viewport and frame headings
c     
c
c     zero subset array tt
c
   
      do 100 k=1,mz
      do 100 j=1,my
      do 100 i=1,mx
       t2(i,j,k)=0.
  100 continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
      write(title,'(1pe9.2)')vm
      title='vm ='//title
      call wtstr(.7,.935,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.93,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')zmin
      title='x axis'
      call wtstr(.18,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.16,.85,title,1,0,0)
c
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      kk=mz2
      do 110 j=1,my
       do 105 i=1,mx
       t2(i,j,k)=t(i,j,kk)
  105 continue
  110 continue
c
c     draw contours in x-y plane
c
      do 115 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  115 continue
c
c     re-zero tt
c
      k=1
      do 125 j=1,my
       do 120 i=1,mx
       t2(i,j,k)=0.
  120 continue
  125 continue
c
c         loading x-z plane
c
      j=my
      jj=my2
      do 130 k=1,mz
      do 130 i=1,mx
       t2(i,j,k)=t(i,jj,k)
  130 continue
c
c     draw contours in x-y plane
c
      do 132 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,2,
     &   vpl,vpr,vpb,vpt)
  132 continue
c
c     loading y-zplane
c
      do 134  k=1,mz 
      do 134  i=1,mx 
       t2(i,j,k)=0.
  134 continue
      icut=1.+(xcut-xmin)/delx
      i=mx
      do 136 j=1,my
      do 136 k=1,mz
       t2(i,j,k)=t(icut,j,k)
  136 continue
      do 138 n=1,ncon 
      call gselnt(0) 
      call sflush 
      tisom=tcon(n)
      call gsplci(n+1) 
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,4,
     &   vpl,vpr,vpb,vpt) 
  138 continue
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.0,1.,0.0,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
c     call line3(x1,y1,z2,x2,y1,z2)
      call line3(x1,y1,z1,x1,y2,z1)
c     call line3(x1,y1,z2,x1,y2,z2)
c     call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c     draw points - NOON MIDNIGHT Sector
c
      ncol=3
      j=my2
      jj=my
c     iskip=2
      jcol=1
      do 140 k=2,mz-1,2
       z1=k*hk+0.05
       y1=jj*hj-0.05
        
         do 140 i=2,mx-1,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 140
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
c        dy=iskip*hj*ty(i,j,k)/vm
         dy=0.
         dz=iskip*hk*tz(i,j,k)/vm
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(jcol)
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 140
c
c      draw arrows - set color for arror heads 
c
        if((ivel.eq.1).and.(dx.ge.0.0)) call gsplci(ncon)
        if((ivel.eq.1).and.(dx.lt.0.0)) call gsplci(5) 
        if((ivel.eq.2).and.(dy.ge.0.0)) call gsplci(ncon) 
        if((ivel.eq.2).and.(dy.lt.0.0)) call gsplci(5) 
        if((ivel.eq.3).and.(dz.ge.0.0)) call gsplci(ncon) 
        if((ivel.eq.3).and.(dz.lt.0.0)) call gsplci(5) 
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  140 continue
c
c     draw points Equatorial region
c
      ncol=3
      k=mz2
      kk=1
c     jskip=2
c     iskip=2
       z1=kk*hk+0.05
       do 145 j=2,my-1,jskip
         y1=j*hj+0.05
         do 145 i=2,mx-1,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 145
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=iskip*hj*ty(i,j,k)/vm
c        dz=iskip*hk*tz(i,j,k)/vm
         dz=0.
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(1)
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 145
c
c      draw arrows - set color for arror heads 
c
         call sflush
        if(dx.ge.0.0) call gsplci(ncon) 
        if(dx.lt.0.0) call gsplci(5) 
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  145 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
      return
      end
c
c     **************************************************************
c
       subroutine conlog(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +            xmin,xmax,ymin,ymax,zmin,zmax,xcut,
     +            time,label,nlevs,ncon,ivel,strtch,tlow,tlim,
     +            tx,ty,tz,t,t2,work,mx,my,mz,mz2,muvwp2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c      ASSUMES log scales
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
c
       real stuff(nx,ny,nz,ngrd),vx(nx,ny,nz),
     +                     vy(nx,ny,nz),vz(nx,ny,nz)
       dimension t(mx,my,mz),tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz),
     +    t2(mx,my,mz),work(muvwp2,muvwp2) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       real eye(3),tlev(6),tcon(18)
       character*4 llbs(18),wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(18)

c
c     skip parameters for field lines and arrows
c      
       jskip=(ny-1)/20
       iskip=(nx-1)/20+1
c
c      dimension for plotted array
c
       my2=my/2+1
c
       t=0.
       t2=0.
       tx=0.
       ty=0.
       tz=0.
c
c      effective step size between points - slight less than
c         unity to ensure arrows do not go out of bounds
c
      hi=.99
      hj=.99
      hk=.99
c
c     al = length of arrow in xy-plane
c     stretch= enlargement of arrows
c
      al=0.6*hi
      al2=0.2
      stretch=2.0*strtch
      vmin=0.00001
      vm=0.0
c 
c      angle of arrow
c
      beta=30./180.*3.1415926
c
c     set color table 
c
      call sflush
      call isoclrs_hot
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.0001)
       aymax=amin1(ymax,grd_ymax(m)-.0001)
       azmax=amin1(zmax,grd_zmax(m)-.0001)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      load T stuff
c
      call filldatav(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +        t,t2,tx,ty,tz,mx,my,mz,xmin,ymin,zmin,
     +         delx,dely,delz,vm,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      find max and minimum values in array t
c
      tmi=0.
      tma=0.
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      dlev=(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=(tlim-tlow)/(ncon-1.)
c      ampl=tlim
c      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=tlow+(n-1)*dcon
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c     ***************************************
c       make contour plots down the middle
c
      my2=my/2+1
      aymin=(ymin+aymax)/2.
c
c     initialize eye position
c
c     eye(1)=-mx
c     eye(2)=-my2*2.
c     eye(3)=mz*3.0
c                   
      eye(1)=mx/2
      eye(2)=-my2*2.
      eye(3)=mz2*3.5

c
c     initialize viewport and frame headings
c     
c
c     zero subset array tt
c
   
      do 100 k=1,mz
      do 100 j=1,my
      do 100 i=1,mx
       t2(i,j,k)=0.
  100 continue
c
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      call wtstr(.4,.975,label,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
      write(title,'(1pe9.2)')vm
      title='vm ='//title
      call wtstr(.7,.935,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.93,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')aymin
      write(wd3,'(f4.0)')zmin
      title='x axis'
      call wtstr(.18,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.16,.85,title,1,0,0)
c
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      kk=mz2
      do 110 j=1,my
       do 105 i=1,mx
       t2(i,j,k)=t(i,j,kk)
  105 continue
  110 continue
c
c     draw contours in x-y plane
c
      do 115 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  115 continue
c
c     re-zero tt
c
      k=1
      do 125 j=1,my
       do 120 i=1,mx
       t2(i,j,k)=0.
  120 continue
  125 continue
c
c         loading x-z plane
c
      j=my
      jj=my2
      do 130 k=1,mz
      do 130 i=1,mx
       t2(i,j,k)=t(i,jj,k)
  130 continue
c
c     draw contours in x-y plane
c
      do 132 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,2,
     &   vpl,vpr,vpb,vpt)
  132 continue
c
c     loading y-zplane
c
      do 134  k=1,mz 
      do 134  i=1,mx 
       t2(i,j,k)=0.
  134 continue
      icut=1.+(xcut-xmin)/delx
      i=mx
      do 136 j=1,my
      do 136 k=1,mz
       t2(i,j,k)=t(icut,j,k)
  136 continue
      do 138 n=1,ncon 
      call gselnt(0) 
      call sflush 
      tisom=tcon(n)
      call gsplci(n+1) 
      call isosrf(t2,mx,mx,my,my,mz,eye,muvwp2,work,tisom,4,
     &   vpl,vpr,vpb,vpt) 
  138 continue
c
c    draw axes lines 
c
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
c
      call set3(0.0,1.,0.0,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
c     call line3(x1,y1,z2,x2,y1,z2)
      call line3(x1,y1,z1,x1,y2,z1)
c     call line3(x1,y1,z2,x1,y2,z2)
c     call line3(x1,y1,z1,x1,y1,z2)
      call sflush
c
c     draw points - NOON MIDNIGHT Sector
c
      ncol=3
      j=my2
      jj=my
c     iskip=2
      jcol=1
      do 140 k=2,mz-1,2
       z1=k*hk+0.05
       y1=jj*hj-0.05
        
         do 140 i=2,mx-1,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 140
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
c        dy=iskip*hj*ty(i,j,k)/vm
         dy=0.
         dz=iskip*hk*tz(i,j,k)/vm
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(jcol)
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 140
c
c      draw arrows - set color for arror heads 
c
        if((ivel.eq.1).and.(dx.ge.0.0)) call gsplci(ncon)
        if((ivel.eq.1).and.(dx.lt.0.0)) call gsplci(5) 
        if((ivel.eq.2).and.(dy.ge.0.0)) call gsplci(ncon) 
        if((ivel.eq.2).and.(dy.lt.0.0)) call gsplci(5) 
        if((ivel.eq.3).and.(dz.ge.0.0)) call gsplci(ncon) 
        if((ivel.eq.3).and.(dz.lt.0.0)) call gsplci(5) 
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  140 continue
c
c     draw points : equatorial
c
      ncol=3
      k=mz2
      kk=1
c     jskip=2
c     iskip=2
       z1=kk*hk+0.05
       do 145 j=2,my-1,jskip
         y1=j*hj+0.05
         do 145 i=2,mx-1,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         if(vmag*strtch.lt.0.05*vm)goto 145
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=iskip*hj*ty(i,j,k)/vm
c        dz=iskip*hk*tz(i,j,k)/vm
         dz=0.
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(1)
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 145
c
c      draw arrows - set color for arror heads 
c
         call sflush
        if(dx.ge.0.0) call gsplci(ncon) 
        if(dx.lt.0.0) call gsplci(5) 
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
c
  145 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
      return
      end
c
c     **************************************************************
c
       subroutine conmap(stuff,vx,vy,vz,bx,by,bz,nx,ny,nz,ngrd,mm,m,
     +       xcraft,ncraft,re_equiv,rearth,
     +       xmin,xmax,ymin,ymax,zmin,zmax,
     +        time,label,nlevs,ncon,strtch,add_dip,ivel,kht,
     +        tx,ty,tz,t,tt,t2,work,mx,my,mz,mz2,muvwp2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
       common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
       dimension t(mx,my,mz),tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz),
     +    tt(mx,my,mz),t2(mx,my,mz2),work(muvwp2,muvwp2) 
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       real xray(1000),yray(1000),zray(1000),
     +       xray1(1000),yray1(1000),zray1(1000)
       dimension stuff(nx,ny,nz,ngrd),vx(nx,ny,nz),xcraft(4,ncraft),
     +                     vy(nx,ny,nz),vz(nx,ny,nz),
     +                     bx(nx,ny,nz),by(nx,ny,nz),bz(nx,ny,nz)
       real eye(3),tlev(6),tcon(14)
       character*4 llbs(14),wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(14)
       logical add_dip
c
c      dimension for plotted array
c
       mx=41
       my=41
       mz=21
c
       mz2=mz/2+1
       my2=my/2+1
       maxpts=1000
c
c      effective step size between points - slight less than
c         unity to ensure arrows do not go out of bounds
c
      hi=.99
      hj=.99
      hk=.99
c
c     al = length of arrow in xy-plane
c     stretch= enlargement of arrows
c
      al=0.6*hi
      al2=0.2
      stretch=2.0*strtch
      vmin=0.00001
c 
c      angle of arrow
c
      beta=30./180.*3.1415926
c
c     set color table 
c
      call sflush
      call isoclrs
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.0001)
       aymax=amin1(ymax,grd_ymax(m)-.0001)
       azmax=amin1(zmax,grd_zmax(m)-.0001)
c
       rx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      height=zmin+delz*0.7*(mz-1)
       height=delz*0.2*(mz-1)
c
c      load T stuff
c
      call filldatav(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +        t,tt,tx,ty,tz,mx,my,mz,xmin,ymin,zmin,
     +         delx,dely,delz,vm,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
       do 20 k=1,mz
        az=zmin+delz*(k-1)
        haz=az-height
        do 20 j=1,my
         ay=ymin+dely*(j-1)
         do 20 i=1,mx
          ax=xmin+delx*(i-1)
          radius=sqrt(ax**2+ay**2+haz**2)
          tt(i,j,k)=radius
c
   20 continue
c
c      find max and minimum values in array t
c
      tmi=0.
      tma=0.
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      dlev=(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=(tma-tmi)/(ncon+1.)
      ampl=(abs(tma)+abs(tmi))/2.
      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=tmi+dcon*n
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)/ampl
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=-my*2.5
      eye(3)=mz2*3.5
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
      title=' : dawn dusk'
      call wtstr(.4,.975,label,2,0,0)
      call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
      title='units '//magnif
      call wtstr(.3,.955,title,1,0,0)
      write(title,'(1pe9.2)')tmi
      title='min '//title
      call wtstr(.6,.955,title,1,0,0)
      write(title,'(1pe9.2)')tma
      title='max '//title
      call wtstr(.8,.955,title,1,0,0)
      write(title,'(1pe9.2)')vm
      title='vm ='//title
      call wtstr(.7,.935,title,1,0,0)
c
      write(wd1,'(f4.0)')xmin
      write(wd2,'(f4.0)')aymax
      write(wd3,'(f4.0)')zmin
      title='y axis'
      call wtstr(.98,.17,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.95,.12,title,1,0,0)
c
      write(wd1,'(f4.0)')axmax
      write(wd2,'(f4.0)')ymin
      write(wd3,'(f4.0)')azmax
      title='z axis'
      call wtstr(.93,.9,title,1,0,0)
      title=wd1//','//wd2//','//wd3
      call wtstr(.9,.85,title,1,0,0)
c
c
c     write(wd1,'(f4.0)')axmax
c     write(wd2,'(f4.0)')aymin
c     write(wd3,'(f4.0)')zmin
c     title='x axis'
c     call wtstr(.05,.6,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.03,.55,title,1,0,0)
c
c    draw earth and grid references
c
c     reset earth so that it is sitting half way up the axis
c      so that you can see something
c
c     do 190 k=1,mz2
c     do 190 j=1,my
c     do 190 i=1,mx
c      tt(i,j,k+mz2)=tt(i,j,k)
c      tt(i,j,k)=0.
c 190 continue
c
      call gsplci(2)
      tisom=rearth
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c
c     zero subset array tt
c
      do 200 k=1,mz
      do 200 j=1,my
      do 200 i=1,mx
       tt(i,j,k)=0.
  200 continue
c
c     load data ------ right hand side
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      kk=mz2
      do 215 j=1,my
       do 210 i=1,mx
       tt(i,j,k)=t(i,j,kk)
  210 continue
  215 continue
c
c     draw contours in x-y plane
c
      do 240 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  240 continue
c
c    draw axes lines 
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
      z22=1.+mz/2+(height)/delz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call line3(x1,y1,z22,x2,y1,z22)
      call line3(x1,y1,z22,x1,y2,z22)
      call line3(x1,y1,z22,x1,y1,z2)
      call line3(x1,y2,z22,x2,y2,z22)
      call line3(x2,y1,z22,x2,y2,z22)
      call sflush
c
c     draw points
c
      ncol=3
      kk=2
      k=mz2+kht
      jskip=3
      iskip=4
       z1=kk*hk+0.05
       do 270 j=1,my,jskip
         y1=j*hj+0.05
         do 270 i=1,mx,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         call sflush
         call gsplci(2)
         if(vmag*strtch.lt.0.10*vm)goto 245
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=jskip*hj*ty(i,j,k)/vm
         dz=iskip*hk*tz(i,j,k)/vm
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(1)
c
c        make simpler by not adding arrows in this panel
c
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         isize=0
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 245
c
c      draw arrows - set color for arror heads 
c
         call sflush
         if(((ivel.eq.1).and.(dx.ge.0.0)).or.
     +      ((ivel.eq.2).and.(dy.ge.0.0)).or.
     +      ((ivel.eq.3).and.(dz.ge.0.0)))then
             call gsplci(15)
         else
             call gsplci(5)
         endif
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
        isize=1
c
c       draw magnetic field line
c
  245   l=0
        dir=0.25*delx
        xi=xmin+delx*(i-1)
        yi=ymin+dely*(j-1)
        zi=zmin+delz*(k-1)
        call trace(bx,by,bz,nx,ny,nz,m,add_dip,
     +       xi,yi,zi,dir,maxpts,xf,yf,zf,
     +       xray,yray,zray,xmin,axmax,ymin,aymax,
     +       zmin+height/2.,azmax-height/2.,l,rearth,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        rad1=sqrt(xi**2+yi**2+zi**2)-2.
        rad2=sqrt(xray(l)**2+yray(l)**2+zray(l)**2)-2.
c
        do 250 nn=1,l
           xray(nn)=1.+(xray(nn)-xmin)/delx 
           yray(nn)=1.+(yray(nn)-ymin)/dely 
           zray(nn)=1.+(zray(nn)+height-zmin)/delz 
  250   continue
c
c       call curve3(xray,yray,zray,l)
c
c       go the other direction just to make sure a ray plotted
c
        l1=0
        dir=-0.25*delx
        call trace(bx,by,bz,nx,ny,nz,m,add_dip,
     +             xi,yi,zi,dir,maxpts,xf1,yf1,zf1,
     +         xray1,yray1,zray1,xmin,axmax,ymin,aymax,
     +             zmin+height/2.,azmax-height/2.,l1,rearth,ngrd,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        rad3=sqrt(xray1(l1)**2+yray1(l1)**2+zray1(l1)**2)-2.
        do 260 nn=1,l1
c
c        convert spatial cordinate to grid cordinate
c
           xray1(nn)=1.+(xray1(nn)-xmin)/delx 
           yray1(nn)=1.+(yray1(nn)-ymin)/dely 
           zray1(nn)=1.+(zray1(nn)+height-zmin)/delz 
  260   continue
c
        call sflush
        if((xray(l).ge.mx-1.).and.(xray1(l1).ge.mx-1.))then
          call gsplci(12)
        else  if((rad2.le.rearth).and.(rad3.le.rearth))then
          call gsplci(5)
        else if((rad1.le.rearth).or.(rad2.le.rearth)
     +              .or.(rad3.le.rearth))then
          call gsplci(7)
        else if(xray(1).le.3.)then
          call gsplci(15)
        else
          goto 270
        endif
c
        call curve3(xray,yray,zray,l)
        call curve3(xray1,yray1,zray1,l1)
c
  270 continue
c
c      draw spacecraft - x-r coords and 3-d coords
c
      do 330 n=1,ncraft
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         aside=sign(1.,ay)
         ar=sqrt(ay**2+az**2)
         ar=aside*ar
         if( (ax.ge.xmin).and.(ax.le.xmax).and.
     +       (ay.ge.ymin).and.(ay.le.ymax).and.
     +       (az.ge.zmin).and.(az.le.zmax) )then
           x1=1.+(ax-0.5-xmin)/delx
           x2=1.+(ax+0.5-xmin)/delx
           y1=1.+(ay-0.5-ymin)/dely
           y2=1.+(ay+0.5-ymin)/dely
           z1=1.+(az+height-0.5-zmin)/delz
           z2=1.+(az+height+0.5-zmin)/delz
           r1=1.+(ar-0.5-ymin)/dely
           r2=1.+(ar+0.5-ymin)/dely
c
c        2-D projection
c
        call sflush
        call gsplci(15)
         call line3(x1,r1,1.,x2,r1,1.)
         call line3(x1,r1,1.,x1,r2,1.)
         call line3(x2,r2,1.,x1,r2,1.)
         call line3(x2,r2,1.,x2,r1,1.)
c
c        3-D position
c
        call sflush
        call gsplci(3)
        call line3(x1,y1,z1,x2,y1,z1)
        call line3(x1,y1,z1,x1,y2,z1)
        call line3(x1,y1,z1,x1,y1,z2)
        call line3(x2,y2,z1,x2,y1,z1)
        call line3(x2,y2,z1,x1,y2,z1)
c
        call line3(x2,y2,z2,x2,y2,z1)
        call line3(x2,y2,z2,x1,y2,z2)
        call line3(x2,y2,z2,x2,y1,z2)
        call line3(x1,y1,z2,x1,y2,z2)
        call line3(x1,y1,z2,x2,y1,z2)
c
        call line3(x1,y2,z1,x1,y2,z2)
        call line3(x2,y1,z1,x2,y1,z2)
        endif
c
        dir=-0.25*delx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,
     +      zmin+height/2.,zmax-height/2.,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
         do 300 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely
         zray1(nn)=1.+(zray(nn)+height-zmin)/delz
  300   continue
c
c       make color choice and plot the grap
c           3d plot
c
         call sflush
         call gsplci(1)
         call curve3(xray1,yray1,zray1,npts)
c
c          2d plot
c
c        side=(-1.)**n
         do 305 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         ar=sqrt((yray(nn)-ydip)**2+(zray(nn)-zdip)**2)
         ar=sign(ar,yray(nn))
c        ar=ar*side
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(ar-ymin)/dely
         zray1(nn)=1.
  305   continue
c        call sflush
c        call gsplci(1)
         call curve3(xray1,yray1,zray1,npts)
c
c       go the other direction
        dir=+0.25*delx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,
     +      zmin+height/2.,zmax-height/2.,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
         do 310 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely
         zray1(nn)=1.+(zray(nn)+height-zmin)/delz
  310   continue
c
c       make color choice and plot the grap
c
c        call sflush
c        call gsplci(9)
         call curve3(xray1,yray1,zray1,npts)
c
c          2d plot
c
c        side=(-1.)**n
         do 315 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         ar=sqrt((yray(nn)-ydip)**2+(zray(nn)-zdip)**2)
         ar=sign(ar,yray(nn))
c        ar=sign(ar,xcraft(2,n))
c        ar=ar*side
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(ar-ymin)/dely
         zray1(nn)=1.
  315   continue
c        call sflush
c        call gsplci(1)
         call curve3(xray1,yray1,zray1,npts)
c
  330 continue
c
c     put color bar
c
      call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
      call gsfais(1)
      call lbseti('CBL',1)
      call pcsetr('CS',1.25)
      call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
      return
      end
c
c     **************************************************************
c
       subroutine concross(stuff,vx,vy,vz,bx,by,bz,nx,ny,nz,
     +       ngrd,mm,m,xcraft,ncraft,re_equiv,rearth,
     +       xmin,xmax,ymin,ymax,zmin,zmax,time,
     +       label,nlevs,ncon,strtch,add_dip,ivel,kht,start,
     +       tx,ty,tz,tt,t,t2,work,mx,my,mz,mz2,muvwp2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
c
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                 sin_tilt,cos_tilt,b0 
c
      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       dimension t(mx,my,mz),tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz),
     +    tt(mx,my,mz),t2(mx,my,mz2),work(muvwp2,muvwp2)
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
c	
       real xray(1000),yray(1000),zray(1000),
     +      xray1(1000),yray1(1000),zray1(1000)
       dimension stuff(nx,ny,nz,ngrd),vx(nx,ny,nz),xcraft(4,ncraft),
     +                     vy(nx,ny,nz),vz(nx,ny,nz),
     +                     bx(nx,ny,nz),by(nx,ny,nz),bz(nx,ny,nz)
       real xrays(2),yrays(2)
       real eye(3),tlev(6),tcon(14)
       character*4 llbs(14)
       character*5 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(14)
       logical add_dip,start
c
      ILAB=0
      IOFFM=10
c
c     skip parameters for field lines and arrows
c      
       jskip=(ny-1)/20
       iskip=(nx-1)/30+1
c
       jskip=4
       iskip=4
c
c      dimension for 3-D plotted array
c
       my2=my/2+1
c
       maxpts=1000
c
c      effective step size between points - slight less than
c         unity to ensure arrows do not go out of bounds
c
      hi=.99
      hj=.99
      hk=.99
c
c     al = length of arrow in xy-plane
c     stretch= enlargement of arrows
c
      al=0.6*hi
      al2=0.2
      stretch=2.0*strtch
      vmin=0.00001
c 
c      angle of arrow
c
      beta=30./180.*3.1415926
c
c     set color table 
c
      call sflush
      call isoclrs
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.0001)
       aymax=amin1(ymax,grd_ymax(m)-.0001)
       azmax=amin1(zmax,grd_zmax(m)-.0001)
       rx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      height=zmin+delz*0.7*(mz-1)
       height=delz*0.2*(mz-1)
c
c      load T stuff
c
      call filldatav(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +        t,tt,tx,ty,tz,mx,my,mz,xmin,ymin,zmin,
     +         delx,dely,delz,vm,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
       do 20 k=1,mz
        az=zmin+delz*(k-1)
        haz=az-height
        do 20 j=1,my
         ay=ymin+dely*(j-1)
         do 20 i=1,mx
          ax=xmin+delx*(i-1)
          radius=sqrt(ax**2+ay**2+haz**2)
          tt(i,j,k)=radius
c
   20 continue
c
c      find max and minimum values in array t
c
      tmi=t(1,1,1)
      tma=t(1,1,1)
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      tma=0.8*tma
      dlev=(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=(tma-tmi)/(ncon+1.)
      ampl=(abs(tma)+abs(tmi))/2.
      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=tmi+dcon*n
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)/ampl
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=-my*2.5
      eye(3)=mz2*4.0
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
c     title=' : dawn dusk'
      call wtstr(.4,.975,label,2,0,0)
c     call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
c     title='units '//magnif
c     call wtstr(.3,.955,title,1,0,0)
c     write(title,'(1pe9.2)')tmi
c     title='min '//title
c     call wtstr(.6,.955,title,1,0,0)
c     write(title,'(1pe9.2)')tma
c     title='max '//title
c     call wtstr(.8,.955,title,1,0,0)
c     write(title,'(1pe9.2)')vm
c     title='vm ='//title
c     call wtstr(.7,.935,title,1,0,0)
c
c     write(wd1,'(f4.0)')xmin
c     write(wd2,'(f4.0)')aymax
c     write(wd3,'(f4.0)')zmin
c     title='y axis'
c     call wtstr(.98,.17,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.95,.12,title,1,0,0)
c
c     write(wd1,'(f4.0)')axmax
c     write(wd2,'(f4.0)')ymin
c     write(wd3,'(f4.0)')azmax
c     title='z axis'
c     call wtstr(.93,.9,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.9,.85,title,1,0,0)
c
c
c     write(wd1,'(f4.0)')axmax
c     write(wd2,'(f4.0)')aymin
c     write(wd3,'(f4.0)')zmin
c     title='x axis'
c     call wtstr(.05,.6,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.03,.55,title,1,0,0)
c
c    draw earth and grid references
c
c     reset earth so that it is sitting half way up the axis
c      so that you can see something
c
c     do 190 k=1,mz2
c     do 190 j=1,my
c     do 190 i=1,mx
c      tt(i,j,k+mz2)=tt(i,j,k)
c      tt(i,j,k)=0.
c 190 continue
c
      call gsplci(2)
      tisom=rearth
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c
c     zero subset array tt
c
      do 200 k=1,mz
      do 200 j=1,my
      do 200 i=1,mx
       tt(i,j,k)=0.
  200 continue
c
c     load data ------ right hand side
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      kk=mz2
      do 215 j=1,my
       do 210 i=1,mx
       tt(i,j,k)=t(i,j,kk)
  210 continue
  215 continue
c
c     draw contours in x-y plane
c
      do 240 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  240 continue
c
c    draw axes lines 
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
      z22=1.+mz/2+(height)/delz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call line3(x1,y1,z22,x2,y1,z22)
      call line3(x1,y1,z22,x1,y2,z22)
      call line3(x1,y1,z22,x1,y1,z2)
      call line3(x1,y2,z22,x2,y2,z22)
      call line3(x2,y1,z22,x2,y2,z22)
      call sflush
c
c     draw points
c
      ijump=-1
      ncol=3
      kk=2
      k=mz2+kht
c     jskip=4
c     iskip=8
       z1=kk*hk+0.05
       do 270 j=1,my,jskip
         y1=j*hj+0.05
         do 270 i=1,mx,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         call sflush
         call gsplci(2)
         if(vmag*strtch.lt.0.10*vm)goto 245
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=jskip*hj*ty(i,j,k)/vm
         dz=iskip*hk*tz(i,j,k)/vm
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(1)
c
c        make simpler by not adding arrows in this panel
c
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         isize=0
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 245
c
c      draw arrows - set color for arror heads 
c
         call sflush
         if(((ivel.eq.1).and.(dx.ge.0.0)).or.
     +      ((ivel.eq.2).and.(dy.ge.0.0)).or.
     +      ((ivel.eq.3).and.(dz.ge.0.0)))then
             call gsplci(15)
         else
             call gsplci(5)
         endif
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
        isize=1
c
c       draw magnetic field line
c
  245   l=0
        dir=0.25*delx
        xi=xmin+delx*(i-1)
        yi=ymin+dely*(j-1)
        zi=zmin+delz*(k-1)
        call trace(bx,by,bz,nx,ny,nz,m,add_dip,
     +         xi,yi,zi,dir,maxpts,xf,yf,zf,
     +         xray,yray,zray,xmin,axmax,ymin,aymax,
     +         zmin+height/2.,azmax-height/2.,l,rearth,ngrd,
     +     grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        rad1=sqrt(xi**2+yi**2+zi**2)-2.
        rad2=sqrt(xray(l)**2+yray(l)**2+zray(l)**2)-2.
c
        do 250 nn=1,l
           xray(nn)=1.+(xray(nn)-xmin)/delx 
           yray(nn)=1.+(yray(nn)-ymin)/dely 
           zray(nn)=1.+(zray(nn)+height-zmin)/delz 
  250   continue
c
c       call curve3(xray,yray,zray,l)
c
c       go the other direction just to make sure a ray plotted
c
        l1=0
        dir=-0.25*delx
        call trace(bx,by,bz,nx,ny,nz,m,add_dip,
     +         xi,yi,zi,dir,maxpts,xf1,yf1,zf1,
     +         xray1,yray1,zray1,xmin,axmax,ymin,aymax,
     +         zmin+height/2.,azmax-height/2.,l1,rearth,ngrd,
     +     grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        rad3=sqrt(xray1(l1)**2+yray1(l1) **2+zray1(l1)**2)-2.
        do 260 nn=1,l1
c
c        convert spatial cordinate to grid cordinate
c
           xray1(nn)=1.+(xray1(nn)-xmin)/delx 
           yray1(nn)=1.+(yray1(nn)-ymin)/dely 
           zray1(nn)=1.+(zray1(nn)+height-zmin)/delz 
  260   continue
c
        call sflush
        if((xray(l).ge.mx-1.).and.(xray1(l1).ge.mx-1.))then
          call gsplci(12)
        else  if((rad2.le.rearth).and.(rad3.le.rearth))then
          call gsplci(5)
        else if((rad1.le.rearth).or.(rad2.le.rearth)
     +              .or.(rad3.le.rearth))then
          ijump=-ijump
          if(ijump.lt.0)goto 270
          call gsplci(7)
c        else if(xray(1).le.3.)then
         else
          call gsplci(15)
c       else
c         goto 270
        endif
c
        call curve3(xray,yray,zray,l)
        call curve3(xray1,yray1,zray1,l1)
c
  270 continue
c
c      draw spacecraft - x-r coords and 3-d coords
c
c       wspace set writing distance to MLT and LAT
      wspace=0.015
      nspace=0
      size=0.25*delx
      do 330 n=1,ncraft
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         aside=sign(1.,ay)
         ar=sqrt(ay**2+az**2)
         ar=aside*ar
         if( (ax.ge.xmin).and.(ax.le.xmax).and.
     +       (ay.ge.ymin).and.(ay.le.ymax).and.
     +       (az.ge.zmin).and.(az.le.zmax) )then
           x1=1.+(ax-size-xmin)/delx
           x2=1.+(ax+size-xmin)/delx
           y1=1.+(ay-size-ymin)/dely
           y2=1.+(ay+size-ymin)/dely
           z1=1.+(az+height-size-zmin)/delz
           z2=1.+(az+height+size-zmin)/delz
           r1=1.+(ar-size-ymin)/dely
           r2=1.+(ar+size-ymin)/dely
c
c        2-D projection
c
         call sflush
         call gsplci(9)
         call line3(x1,y1,1.,x2,y1,1.)
         call line3(x1,y1,1.,x1,y2,1.)
         call line3(x2,y2,1.,x1,y2,1.)
         call line3(x2,y2,1.,x2,y1,1.)
c
c        3-D position
c
        call sflush
        call gsplci(9)
        call line3(x1,y1,z1,x2,y1,z1)
        call line3(x1,y1,z1,x1,y2,z1)
        call line3(x1,y1,z1,x1,y1,z2)
        call line3(x2,y2,z1,x2,y1,z1)
        call line3(x2,y2,z1,x1,y2,z1)
c
        call line3(x2,y2,z2,x2,y2,z1)
        call line3(x2,y2,z2,x1,y2,z2)
        call line3(x2,y2,z2,x2,y1,z2)
        call line3(x1,y1,z2,x1,y2,z2)
        call line3(x1,y1,z2,x2,y1,z2)
c
        call line3(x1,y2,z1,x1,y2,z2)
        call line3(x2,y1,z1,x2,y1,z2)
        endif
c
        dir=-0.25*delx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,
     +      zmin+height/2.,zmax-height/2.,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        test for connection to earth and write out position
c
        call gsplci(1)
        sx=(xray(npts)-xdip)*re_equiv
        sy=(yray(npts)-ydip)*re_equiv
        sz=(zray(npts)-zdip)*re_equiv
        rtot=sqrt(sx**2+sy**2+sz**2)
        if((rtot/re_equiv.le.rearth+2.).and.
     +          (rtot/re_equiv.gt.0.5*rearth))then
         nspace=nspace+1
c
c        find polar coordinate : first rotate by dipole tilt
c
         sx1=sx*cos_tilt-sz*sin_tilt
         sz1=sx*sin_tilt+sz*cos_tilt
         sy1=sy
         rtot=sqrt(sx1**2+sy1**2+sz1**2)
         if(sz1.ge.0)then
          colat=acos(sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=90.-colat
         else
          colat=acos(-sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=-(90.-colat)
         endif
c
c          find local time
c
         if(sy1.ge.0.)then
          alt=atan2(sy1,sx1)
          alt=12.*alt/3.1416
         else
          alt=atan2(-sy1,sx1)
          alt=12.*(2.-alt/3.1416)
         endif
         arad=1.
c        write(wd1,'(f5.1)')arad
c        write(wd2,'(f5.1)')alat
c        write(wd3,'(f5.1)')alt
c        title=wd1//','//wd2//','//wd3//' '
c        call wtstr(.4,.9-wspace*(nspace-1),title,1,0,0)
c        write(title,'(i2)')n
c        title='craft lat,MLT'//title
c        call wtstr(.20,.9-wspace*(nspace-1),title,1,0,0)
      endif     
c
         do 300 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely
         zray1(nn)=1.+(zray(nn)+height-zmin)/delz
  300   continue
c
c       make color choice and plot the grap
c           3d plot
c
         call sflush
         call gsplci(1)
         call curve3(xray1,yray1,zray1,npts)
c
c          2d plot
c
c        side=(-1.)**n
         do 305 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         ar=sqrt((yray(nn)-ydip)**2+(zray(nn)-zdip)**2)
         ar=sign(ar,yray(nn))
c        ar=ar*side
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely  
c        yray1(nn)=1.+(ar-ymin)/dely
         zray1(nn)=1.
  305   continue
c        call sflush
c        call gsplci(1)
         call curve3(xray1,yray1,zray1,npts)
c
c       go the other direction
        dir=+0.25*delx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,
     +      zmin+height/2.,zmax-height/2.,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        sx=(xray(npts)-xdip)*re_equiv
        sy=(yray(npts)-ydip)*re_equiv
        sz=(zray(npts)-zdip)*re_equiv
        rtot=sqrt(sx**2+sy**2+sz**2)
        if((rtot/re_equiv.le.rearth+2.).
     +          and.(rtot/re_equiv.gt.0.5*rearth))then
         nspace=nspace+1
c
c        find polar coordinate : first rotate by dipole tilt
c
         sx1=sx*cos_tilt-sz*sin_tilt
         sz1=sx*sin_tilt+sz*cos_tilt
c
         sy1=sy
         rtot=sqrt(sx1**2+sy1**2+sz1**2)
         if(sz1.ge.0)then
          colat=acos(sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=90.-colat
         else
          colat=acos(-sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=-(90.-colat)
         endif
c
c          find local time
c
         if(sy1.gt.0.)then
          alt=atan2(sy1,sx1)
          alt=12.*alt/3.1416
         else
          alt=atan2(-sy1,sx1)
          alt=12.*(2.-alt/3.1416)
         endif
         arad=1.
c        write(wd1,'(f5.1)')arad
c        write(wd2,'(f5.1)')alat
c        write(wd3,'(f5.1)')alt
c        title=wd1//','//wd2//','//wd3//' '
c        call wtstr(.4,.9-wspace*(nspace-1),title,1,0,0)
c        write(title,'(i2)')n
c        title='craft lat,MLT'//title
c        call wtstr(.20,.9-wspace*(nspace-1),title,1,0,0)
      endif

c
         do 310 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely
         zray1(nn)=1.+(zray(nn)+height-zmin)/delz
  310   continue
c
c       make color choice and plot the grap
c
c        call sflush
c        call gsplci(9)
         call curve3(xray1,yray1,zray1,npts)
c
c          2d plot
c
c        side=(-1.)**n
         do 315 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         ar=sqrt((yray(nn)-ydip)**2+(zray(nn)-zdip)**2)
         ar=sign(ar,yray(nn))
c        ar=sign(ar,xcraft(2,n))
c        ar=ar*side
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely 
c        yray1(nn)=1.+(ar-ymin)/dely
         zray1(nn)=1.
  315   continue
c        call sflush
c        call gsplci(1)
         call curve3(xray1,yray1,zray1,npts)
c
  330 continue
c
c     put color bar
c
c     call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
c     call gsfais(1)
c     call lbseti('CBL',1)
c     call pcsetr('CS',1.25)
c     call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
c     abit=1.
c     avalue=10.
c     value=10.*avalue
c     fmin=tmi
c     fmax=tma
c
c     do 450 n=ncraft,2,-1
c        ax=xcraft(1,n)/re_equiv
c        ay=xcraft(2,n)/re_equiv
c        az=xcraft(3,n)/re_equiv
c        if( (ax.lt.xmin+abit).or.(ax.gt.xmax-abit).or.
c    +       (ay.lt.ymin+abit).or.(ay.gt.ymax-abit).or.
c    +       (az.lt.zmin+abit).or.(az.gt.zmax-abit) )goto 470
c
c         xp=1.+(ax-xmin)/delx
c         i1=xp+1
c         i2=i1+1
c         dx=xp-(i1-1.)
c         ddx=1.-dx
c
c         yp=1.+(ay-ymin)/dely
c         j1=yp+1
c         j2=j1+1
c         dy=yp-(j1-1.)
c         ddy=1.-dy
c
c         zp=1.+(az-zmin)/delz
c         k1=zp+1
c         k2=k1+1
c         dz=zp-(k1-1.)
c         ddz=1.-dz
c
c         do 410 k=1,mz
c         do 410 j=1,my
c            cross(j,k)=t(i1,j,k)*ddx+
c    +                       t(i2,j,k)*dx
c 410   continue
c
c     call frame
c     call gselnt(0)
c     call gsplci(1)
c     call agseti('FRAME.',2)
c     call agseti('SET.',-1)
c
c     write(title,'(f7.3)')time
c     title='UT = '//title
c     call wtstr(.7,.975,title,2,0,0)
c     call wtstr(.4,.975,label,2,0,0)
c     write(title,'(f7.4)')fmin
c     title='fmin'//title
c     call wtstr(.15,.98,title,1,0,0)
c     write(title,'(f7.4)')fmax
c     title='fmax'//title
c     call wtstr(.3,.98,title,1,0,0)
c     title='Y-Z Plane'
c     call wtstr(.9,.98,title,1,0,0)
c     clev=(fmax-fmin)/(ncon+1.)
c     if(.not.start) call cnrccf(cross,my,my,mz,fmin,
c    +             fmax,clev,0,-1,-1012,2.5,0,1)
c     IRECMN=18
c     call conrec(cross,my,my,mz,fmin,
c    +             fmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
c       call gsplci(16)
c        nl=11
c        n2=(nl-1)/2
c       do nn=1,nl
c         ns=(nn-n2)/2
c         shift=ns*.025
c         xrays(1)=yp-.5
c         xrays(2)=yp+.5
c         yrays(1)=zp+shift
c         yrays(2)=zp+shift
c         call curve(xrays,yrays,2)
c         xrays(1)=yp+shift
c         xrays(2)=yp+shift
c         yrays(1)=zp+.5
c         yrays(2)=zp-.5
c       call curve(xrays,yrays,2)
c       enddo
c 450 continue
c
c      make an equatoiral cut for either IMP 8 and Geotail
c
c 470 do 490 n=ncraft,2,-1
c        ax=xcraft(1,n)/re_equiv
c        ay=xcraft(2,n)/re_equiv
c        az=xcraft(3,n)/re_equiv
c        if( (ax.lt.xmin+abit).or.(ax.gt.xmax-abit).or.
c    +       (ay.lt.ymin+abit).or.(ay.gt.ymax-abit).or.
c    +       (az.lt.zmin+abit).or.(az.gt.zmax-abit) )goto 500
c
c         xp=1.+(ax-xmin)/delx
c         i1=xp+1
c         i2=i1+1
c         dx=xp-(i1-1.)
c         ddx=1.-dx
c
c         yp=1.+(ay-ymin)/dely
c         j1=yp+1
c         j2=j1+1
c         dy=yp-(j1-1.)
c         ddy=1.-dy
c
c         zp=1.+(az-zmin)/delz
c         k1=zp+1
c         k2=k1+1
c         dz=zp-(k1-1.)
c         ddz=1.-dz
c
c         do 480 i=1,mx
c         do 480 j=1,my
c            along(i,j)=t(i,j,k1)*ddz+
c    +                       t(i,j,k2)*dz
c 480   continue
c
c     call frame
c     call gselnt(0)
c     call gsplci(1)
c     call agseti('FRAME.',2)
c     call agseti('SET.',-1)
c
c     write(title,'(f7.3)')time
c     title='UT = '//title
c     call wtstr(.7,.975,title,2,0,0)
c     call wtstr(.4,.975,label,2,0,0)
c     write(title,'(f7.4)')fmin
c     title='fmin'//title
c     call wtstr(.15,.98,title,1,0,0)
c     title='fmax'//title
c     write(title,'(f7.4)')fmax
c     call wtstr(.3,.98,title,1,0,0)
c     title='X-Y Plane'
c     call wtstr(.9,.98,title,1,0,0)
c     clev=(fmax-fmin)/(ncon+1.)
c     if(.not.start) then
c        call cnrccf(along,mx,mx,my,fmin,
c    +             fmax,clev,0,-1,-1012,2.5,0,1)
c     else
c       IRECMN=18
c       call conrec(along,mx,mx,my,fmin,
c    +             fmax,clev,0,-1,-1012)
c     endif
c
c     draw in position of spacecraft
c
c       call gsplci(16)
c        nl=11
c        n2=(nl-1)/2
c       do nn=1,nl
c         ns=(nn-n2)/2
c         shift=ns*.025
c         xrays(1)=xp-.5
c         xrays(2)=xp+.5
c         yrays(1)=yp+shift
c         yrays(2)=yp+shift
c         call curve(xrays,yrays,2)
c         xrays(1)=xp+shift
c         xrays(2)=xp+shift
c         yrays(1)=yp+.5
c         yrays(2)=yp-.5
c       call curve(xrays,yrays,2)
c       enddo
c 490 continue
c
c      make a 2-D along tail cut for either IMP 8 and Geotail
c
c 500 do 530 n=ncraft,2,-1
c        ax=xcraft(1,n)/re_equiv
c        ay=xcraft(2,n)/re_equiv
c        az=xcraft(3,n)/re_equiv
c        if( (ax.lt.xmin+abit).or.(ax.gt.xmax-abit).or.
c    +       (ay.lt.ymin+abit).or.(ay.gt.ymax-abit).or.
c    +       (az.lt.zmin+abit).or.(az.gt.zmax-abit) )return
c
c         xp=1.+(ax-xmin)/delx
c         i1=xp+1
c         i2=i1+1
c         dx=xp-(i1-1.)
c         ddx=1.-dx
c
c         yp=1.+(ay-ymin)/dely
c         j1=yp+1
c         j2=j1+1
c         dy=yp-(j1-1.)
c         ddy=1.-dy
c
c         zp=1.+(az-zmin)/delz
c         k1=zp+1
c         k2=k1+1
c         dz=zp-(k1-1.)
c         ddz=1.-dz
c
c         do 520 i=1,mx
c         do 520 k=1,mz
c            along(i,k)=t(i,j1,k)*ddy+
c    +                       t(i,j2,k)*dy
c 520   continue
c
c     call frame
c     call gselnt(0)
c     call gsplci(1)
c     call agseti('FRAME.',2)
c     call agseti('SET.',-1)
c
c     write(title,'(f7.3)')time
c     title='UT = '//title
c     call wtstr(.7,.975,title,2,0,0)
c     call wtstr(.4,.975,label,2,0,0)
c     write(title,'(f7.4)')fmin
c     title='fmin'//title
c     call wtstr(.15,.98,title,1,0,0)
c     title='fmax'//title
c     write(title,'(f7.4)')fmax
c     call wtstr(.3,.98,title,1,0,0)
c     title='X-Z Plane'
c     call wtstr(.9,.98,title,1,0,0)
c     clev=(fmax-fmin)/(ncon+1.)
c     if(.not.start) then
c        call cnrccf(along,mx,mx,mz,fmin,
c    +             fmax,clev,0,-1,-1012,2.5,0,1)
c     else
c       IRECMN=18
c       call conrec(along,mx,mx,mz,fmin,
c    +             fmax,clev,0,-1,-1012)
c     endif
c
c     draw in position of spacecraft
c
c       call gsplci(16)
c        nl=11
c        n2=(nl-1)/2
c       do nn=1,nl
c         ns=(nn-n2)/2
c         shift=ns*.025
c         xrays(1)=xp-.5
c         xrays(2)=xp+.5
c         yrays(1)=zp+shift
c         yrays(2)=zp+shift
c         call curve(xrays,yrays,2)
c         xrays(1)=xp+shift
c         xrays(2)=xp+shift
c         yrays(1)=zp+.5
c         yrays(2)=zp-.5
c       call curve(xrays,yrays,2)
c       enddo
c 530 continue
c
      return
      end
c
c     **************************************************************
c
       subroutine contop(stuff,vx,vy,vz,bx,by,bz,nx,ny,nz,
     +       ngrd,mm,m,xcraft,ncraft,re_equiv,rearth,
     +       xmin,xmax,ymin,ymax,zmin,zmax,time,
     +        label,nlevs,ncon,strtch,add_dip,ivel,kht,start,
     +       tx,ty,tz,tt,t,t2,work,mx,my,mz,mz2,muvwp2,
     +       grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c      subroutine to plot nlevs isosurfaces and then plot contours along
c        x-y and x-z planes
c        nlevs number of isossurfaces to be plotted - max 4
c        ncon  number of contours to be plotted     - max 14
c
c
      common /rotation/v_rot,r_rot,rot_angle,xdip,ydip,zdip,
     +                  sin_tilt,cos_tilt,b0 

      COMMON /CONRE4/ ISIZEL     ,ISIZEM     ,ISIZEP     ,NREP       ,
     1                NCRT       ,ILAB       ,NULBLL     ,IOFFD      ,
     2                EXT        ,IOFFM      ,ISOLID     ,NLA        ,
     3                NLM        ,XLT        ,YBT        ,SIDE
      COMMON /RECINT/ IRECMJ     ,IRECMN     ,IRECTX
c
       dimension t(mx,my,mz),tx(mx,my,mz),ty(mx,my,mz),tz(mx,my,mz),
     +    tt(mx,my,mz),t2(mx,my,mz2),work(muvwp2,muvwp2)
       dimension grd_xmin(ngrd),grd_xmax(ngrd),
     +           grd_ymin(ngrd),grd_ymax(ngrd),
     +           grd_zmin(ngrd),grd_zmax(ngrd)
       real xray(1000),yray(1000),zray(1000),
     +      xray1(1000),yray1(1000),zray1(1000)
       dimension stuff(nx,ny,nz,ngrd),vx(nx,ny,nz),xcraft(4,ncraft),
     +                     vy(nx,ny,nz),vz(nx,ny,nz),
     +                     bx(nx,ny,nz),by(nx,ny,nz),bz(nx,ny,nz)
       real xrays(2),yrays(2)
       real eye(3),tlev(6),tcon(14)
       character*4 llbs(14)
       character*5 wd1,wd2,wd3
       character*8 label,magnif
       character*20 title
       integer vpl,vpr,vpb,vpt,lind(14)
       logical add_dip,start
c
      ILAB=0
      IOFFM=10
c
c     skip parameters for field lines and arrows
c      
c      jskip=(ny-1)/20
c      iskip=(nx-1)/30+1

       jskip=4
       iskip=4
c
c      dimension for 3-D plotted array
c
       my2=my/2+1
c
       maxpts=1000
       rx=(grd_xmax(m)-grd_xmin(m))/(nx-1.)
c
c      effective step size between points - slight less than
c         unity to ensure arrows do not go out of bounds
c
      hi=.99
      hj=.99
      hk=.99
c
c     al = length of arrow in xy-plane
c     stretch= enlargement of arrows
c
      al=0.6*hi
      al2=0.2
      stretch=2.0*strtch
      vmin=0.00001
c 
c      angle of arrow
c
      beta=30./180.*3.1415926
c
c     set color table 
c
      call sflush
      call isoclrs
c
c      t is the stuff to be plotted covering the region
c         xmin-xmax,ymin-ymax,zmin-zmax
c
c      set up evenly spaced gridding for T to be plotted
c
c
       axmax=amin1(xmax,grd_xmax(m)-.00001)
       aymax=amin1(ymax,grd_ymax(m)-.00001)
       azmax=amin1(zmax,grd_zmax(m)-.00001)
c
       delx=(axmax-xmin)/float(mx-1)
       dely=(aymax-ymin)/float(my-1)
       delz=(azmax-zmin)/float(mz-1)
c
c      set decrements have even spacing
c
c      delx=amin1(delx,dely,delz)
c      dely=amin1(delx,dely,delz)
c      delz=amin1(delx,dely,delz)
c
       axmax=xmin+delx*(mx-1)
       aymax=ymin+dely*(my-1)
       azmax=zmin+delz*(mz-1)
c
c      height=zmin+delz*0.7*(mz-1)
       height=delz*0.2*(mz-1)
c
c      load T stuff
c
      call filldatav(stuff,vx,vy,vz,nx,ny,nz,ngrd,mm,m,
     +  t,tt,tx,ty,tz,mx,my,mz,xmin,ymin,zmin,delx,dely,delz,vm,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
       do 20 k=1,mz
        az=zmin+delz*(k-1)
        haz=az-height
        do 20 j=1,my
         ay=ymin+dely*(j-1)
         do 20 i=1,mx
          ax=xmin+delx*(i-1)
          radius=sqrt(ax**2+ay**2+haz**2)
          tt(i,j,k)=radius
c
   20 continue
c
c      find max and minimum values in array t
c
      tmi=t(1,1,1)
      tma=t(1,1,1)
      do 40 k=1,mz
      do 40 j=1,my
      do 40 i=1,mx
        tmi=amin1(t(i,j,k),tmi)
        tma=amax1(t(i,j,k),tma)
  40  continue
c
c      set iso levels for surface plots
c
      tma=0.8*tma
      dlev=(tma-tmi)/(nlevs+1.)
      do 50 n=1,nlevs
        tlev(n)=tmi+dlev*n
   50 continue
c
c     set higher resolution contouring
c
      dcon=(tma-tmi)/(ncon+1.)
      ampl=(abs(tma)+abs(tmi))/2.
      write(magnif,'(1pe8.2)') ampl
      do 60 n=1,ncon
        tcon(n)=tmi+dcon*n
        lind(n)=n+1
        write(llbs(n),'(f4.1)') tcon(n)/ampl
   60 continue
c
c    set viewport size
c
c
      vpl=3200
      vpr=32760
      vpb=3200
      vpt=32760
c
c     initialize eye position
c
      eye(1)=mx/2.
      eye(2)=my/2.
      eye(3)=mz*10.
c
c     initialize viewport and frame headings
c     
      call frame
      call gselnt(0)
      call gsplci(1)
      call agseti('FRAME.',2)
      call agseti('SET.',-1)
c
c     title=' : dawn dusk'
      call wtstr(.4,.975,label,2,0,0)
c     call wtstr(.6,.975,title,2,0,0)
      write(title,'(f7.3)')time
      title='ut = '//title
      call wtstr(.8,.975,title,2,0,0)
c
c     title='units '//magnif
c     call wtstr(.3,.955,title,1,0,0)
c     write(title,'(1pe9.2)')tmi
c     title='min '//title
c     call wtstr(.6,.955,title,1,0,0)
c     write(title,'(1pe9.2)')tma
c     title='max '//title
c     call wtstr(.8,.955,title,1,0,0)
c     write(title,'(1pe9.2)')vm
c     title='vm ='//title
c     call wtstr(.7,.935,title,1,0,0)
c
c     write(wd1,'(f4.0)')xmin
c     write(wd2,'(f4.0)')aymax
c     write(wd3,'(f4.0)')zmin
c     title='y axis'
c     call wtstr(.98,.17,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.95,.12,title,1,0,0)
c
c     write(wd1,'(f4.0)')axmax
c     write(wd2,'(f4.0)')ymin
c     write(wd3,'(f4.0)')azmax
c     title='z axis'
c     call wtstr(.93,.9,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.9,.85,title,1,0,0)
c
c
c     write(wd1,'(f4.0)')axmax
c     write(wd2,'(f4.0)')aymin
c     write(wd3,'(f4.0)')zmin
c     title='x axis'
c     call wtstr(.05,.6,title,1,0,0)
c     title=wd1//','//wd2//','//wd3
c     call wtstr(.03,.55,title,1,0,0)
c
c    draw earth and grid references
c
c     reset earth so that it is sitting half way up the axis
c      so that you can see something
c
c     do 190 k=1,mz2
c     do 190 j=1,my
c     do 190 i=1,mx
c      tt(i,j,k+mz2)=tt(i,j,k)
c      tt(i,j,k)=0.
c 190 continue
c
      call gsplci(2)
      tisom=rearth
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,-3,
     &   vpl,vpr,vpb,vpt)
c
c
c     zero subset array tt
c
      do 200 k=1,mz
      do 200 j=1,my
      do 200 i=1,mx
       tt(i,j,k)=0.
  200 continue
c
c     load data ------ right hand side
c
c          loading x-y plane - running from y = my/2 to  my
c
      k=1
      kk=mz2
      do 215 j=1,my
       do 210 i=1,mx
       tt(i,j,k)=t(i,j,kk)
  210 continue
  215 continue
c
c     draw contours in x-y plane
c
      do 240 n=1,ncon
      call gselnt(0)
      call sflush
      tisom=tcon(n)
      call gsplci(n+1)
      call isosrf(tt,mx,mx,my,my,mz,eye,muvwp2,work,tisom,1,
     &   vpl,vpr,vpb,vpt)
  240 continue
c
c    draw axes lines 
c
      x1=1
      x2=mx
      y1=1
      y2=my
      z1=1
      z2=mz
      z22=1.+mz/2+(height)/delz
c
      call set3(0.,1.,0.,1.,x1,x2,y1,y2,z1,z2,eye)
      call sflush
      call gsplci(1)
      call line3(x1,y1,z1,x2,y1,z1)
      call line3(x1,y1,z1,x1,y2,z1)
      call line3(x1,y1,z1,x1,y1,z2)
      call line3(x1,y1,z22,x2,y1,z22)
      call line3(x1,y1,z22,x1,y2,z22)
      call line3(x1,y1,z22,x1,y1,z2)
      call line3(x1,y2,z22,x2,y2,z22)
      call line3(x2,y1,z22,x2,y2,z22)
      call sflush
c
c     draw points
c
      ijump=-1
      ncol=3
      kk=2
      k=mz2+kht
c     jskip=2
c     iskip=4
       z1=kk*hk+0.05
       do 270 j=1,my,jskip
         y1=j*hj+0.05
         do 270 i=1,mx,iskip
         x1=i*hi+0.05
c
c        find relative size of arrow and skip out if too small
c
         vmag=sqrt(tx(i,j,k)**2+ty(i,j,k)**2+tz(i,j,k)**2)
         call sflush
         call gsplci(2)
         if(vmag*strtch.lt.0.10*vm)goto 245
c
c        arrow length
c
         dx=iskip*hi*tx(i,j,k)/vm
         dy=jskip*hj*ty(i,j,k)/vm
         dz=iskip*hk*tz(i,j,k)/vm
c
         dx=stretch*dx
         dy=stretch*dy
         dz=stretch*dz
c
         x2=x1+dx
         y2=y1+dy
         z2=z1+dz
c
         call sflush
c
         call gsplci(1)
c
c        make simpler by not adding arrows in this panel
c
         call line3(x1,y1,z1,x2,y2,z2)
c
c        test if you can fit an arrow head to the line
c
         isize=0
         if((abs(dx).lt.al2).and.(abs(dy).lt.al2)
     +         .and.(abs(dz).lt.al2)) goto 245
c
c      draw arrows - set color for arror heads 
c
         call sflush
         if(((ivel.eq.1).and.(dx.ge.0.0)).or.
     +      ((ivel.eq.2).and.(dy.ge.0.0)).or.
     +      ((ivel.eq.3).and.(dz.ge.0.0)))then
             call gsplci(15)
         else
             call gsplci(5)
         endif
c
        call arwxy(dx,dy,al,beta,adx1,ady1,adx2,ady2)
        call arwxy(dy,dz,al,beta,ady1,adz1,ady2,adz2)
c
        call line3(x2,y2,z2,x2+adx1,y2+ady1,z2+adz1)
        call line3(x2,y2,z2,x2+adx2,y2+ady2,z2+adz2)
        isize=1
c
c       draw magnetic field line
c
  245   l=0
        dir=0.25*delx
        xi=xmin+delx*(i-1)
        yi=ymin+dely*(j-1)
        zi=zmin+delz*(k-1)
        call trace(bx,by,bz,nx,ny,nz,m,add_dip,
     +             xi,yi,zi,dir,maxpts,xf,yf,zf,
     +         xray,yray,zray,xmin,axmax,ymin,aymax,
     +         zmin+height/2.,azmax-height/2.,l,rearth,ngrd,
     +     grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        rad1=sqrt(xi**2+yi**2+zi**2)-2.
        rad2=sqrt(xray(l)**2+yray(l)**2+zray(l)**2)-2.
c
        do 250 nn=1,l
           xray(nn)=1.+(xray(nn)-xmin)/delx 
           yray(nn)=1.+(yray(nn)-ymin)/dely 
           zray(nn)=1.+(zray(nn)+height-zmin)/delz 
  250   continue
c
c       call curve3(xray,yray,zray,l)
c
c       go the other direction just to make sure a ray plotted
c
        l1=0
        dir=-0.25*delx
        call trace(bx,by,bz,nx,ny,nz,m,add_dip,
     +             xi,yi,zi,dir,maxpts,xf1,yf1,zf1,
     +         xray1,yray1,zray1,xmin,axmax,ymin,aymax,
     +         zmin+height/2.,azmax-height/2.,l1,rearth,ngrd,
     +   grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        rad3=sqrt(xray1(l1)**2+yray1(l1)**2+zray1(l1)**2)-2.
        do 260 nn=1,l1
c
c        convert spatial cordinate to grid cordinate
c
           xray1(nn)=1.+(xray1(nn)-xmin)/delx 
           yray1(nn)=1.+(yray1(nn)-ymin)/dely 
           zray1(nn)=1.+(zray1(nn)+height-zmin)/delz 
  260   continue
c
        call sflush
        if((xray(l).ge.mx-1.).and.(xray1(l1).ge.mx-1.))then
          call gsplci(12)
        else  if((rad2.le.rearth).and.(rad3.le.rearth))then
          call gsplci(5)
        else if((rad1.le.rearth).or.(rad2.le.rearth)
     +              .or.(rad3.le.rearth))then
          ijump=-ijump
          if(ijump.lt.0)goto 270
          call gsplci(7)
c        else if(xray(1).le.3.)then
         else
          call gsplci(15)
c       else
c         goto 270
        endif
c
        call curve3(xray,yray,zray,l)
        call curve3(xray1,yray1,zray1,l1)
c
  270 continue
c
c      draw spacecraft - x-r coords and 3-d coords
c
c       wspace set writing distance to MLT and LAT
      wspace=0.015
      nspace=0
      size=0.5*delx
      do 330 n=1,ncraft
         ax=xcraft(1,n)/re_equiv
         ay=xcraft(2,n)/re_equiv
         az=xcraft(3,n)/re_equiv
         aside=sign(1.,ay)
         ar=sqrt(ay**2+az**2)
         ar=aside*ar
         if( (ax.ge.xmin).and.(ax.le.xmax).and.
     +       (ay.ge.ymin).and.(ay.le.ymax).and.
     +       (az.ge.zmin).and.(az.le.zmax) )then
           x1=1.+(ax-size-xmin)/delx
           x2=1.+(ax+size-xmin)/delx
           y1=1.+(ay-size-ymin)/dely
           y2=1.+(ay+size-ymin)/dely
           z1=1.+(az+height-size-zmin)/delz
           z2=1.+(az+height+size-zmin)/delz
           r1=1.+(ar-size-ymin)/dely
           r2=1.+(ar+size-ymin)/dely
c
c        2-D projection
c
c       call sflush
c       call gsplci(15)
c        call line3(x1,y1,1.,x2,y1,1.)
c        call line3(x1,y1,1.,x1,y2,1.)
c        call line3(x2,y2,1.,x1,y2,1.)
c        call line3(x2,y2,1.,x2,y1,1.)
c
c        3-D position
c
        call sflush
        call gsplci(9)
        call line3(x1,y1,z1,x2,y1,z1)
        call line3(x1,y1,z1,x1,y2,z1)
        call line3(x1,y1,z1,x1,y1,z2)
        call line3(x2,y2,z1,x2,y1,z1)
        call line3(x2,y2,z1,x1,y2,z1)
c
        call line3(x2,y2,z2,x2,y2,z1)
        call line3(x2,y2,z2,x1,y2,z2)
        call line3(x2,y2,z2,x2,y1,z2)
        call line3(x1,y1,z2,x1,y2,z2)
        call line3(x1,y1,z2,x2,y1,z2)
c
        call line3(x1,y2,z1,x1,y2,z2)
        call line3(x2,y1,z1,x2,y1,z2)
        endif
c
        dir=-0.25*rx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,
     +      zmin+height/2.,zmax-height/2.,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +      grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
c        test for connection to earth and write out position
c
        call gsplci(1)
        sx=(xray(npts)-xdip)*re_equiv
        sy=(yray(npts)-ydip)*re_equiv
        sz=(zray(npts)-zdip)*re_equiv
        rtot=sqrt(sx**2+sy**2+sz**2)
        if((rtot/re_equiv.le.rearth+2.).and.
     +          (rtot/re_equiv.gt.0.5*rearth))then
         nspace=nspace+1
c
c        find polar coordinate : first rotate by dipole tilt
c
         sx1=sx*cos_tilt-sz*sin_tilt
         sz1=sx*sin_tilt+sz*cos_tilt
         sy1=sy
         rtot=sqrt(sx1**2+sy1**2+sz1**2)
         if(sz1.ge.0)then
          colat=acos(sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=90.-colat
         else
          colat=acos(-sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=-(90.-colat)
         endif
c
c          find local time
c
         if(sy1.ge.0.)then
          alt=atan2(sy1,sx1)
          alt=12.*alt/3.1416
         else
          alt=atan2(-sy1,sx1)
          alt=12.*(2.-alt/3.1416)
         endif
         arad=1.
c        write(wd1,'(f5.1)')arad
c        write(wd2,'(f5.1)')alat
c        write(wd3,'(f5.1)')alt
c        title=wd1//','//wd2//','//wd3//' '
c        call wtstr(.4,.9-wspace*(nspace-1),title,1,0,0)
c        write(title,'(i2)')n
c        title='craft lat,MLT'//title
c        call wtstr(.20,.9-wspace*(nspace-1),title,1,0,0)
      endif     
c
         do 300 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely
         zray1(nn)=1.+(zray(nn)+height-zmin)/delz
  300   continue
c
c       make color choice and plot the grap
c           3d plot
c
         call sflush
         call gsplci(1)
         call curve3(xray1,yray1,zray1,npts)
c
c          2d plot
c
c        side=(-1.)**n
c        do 305 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
c        ar=sqrt((yray(nn)-ydip)**2+(zray(nn)-zdip)**2)
c        ar=sign(ar,yray(nn))
c        ar=ar*side
c        xray1(nn)=1.+(xray(nn)-xmin)/delx
c        yray1(nn)=1.+(yray(nn)-ymin)/dely  
c        yray1(nn)=1.+(ar-ymin)/dely
c        zray1(nn)=1.
c 305   continue
c        call sflush
c        call gsplci(1)
c        call curve3(xray1,yray1,zray1,npts)
c
c       go the other direction
        dir=+0.25*rx
        call rungem(bx,by,bz,nx,ny,nz,m,rx,
     +      ax,ay,az,xmin,xmax,ymin,ymax,
     +      zmin+height/2.,zmax-height/2.,rearth,
     +      add_dip,xray,yray,zray,maxpts,npts,dir,ngrd,
     +    grd_xmin,grd_xmax,grd_ymin,grd_ymax,grd_zmin,grd_zmax)
c
        sx=(xray(npts)-xdip)*re_equiv
        sy=(yray(npts)-ydip)*re_equiv
        sz=(zray(npts)-zdip)*re_equiv
        rtot=sqrt(sx**2+sy**2+sz**2)
        if((rtot/re_equiv.le.rearth+2.).
     +          and.(rtot/re_equiv.gt.0.5*rearth))then
         nspace=nspace+1
c
c        find polar coordinate : first rotate by dipole tilt
c
         sx1=sx*cos_tilt-sz*sin_tilt
         sz1=sx*sin_tilt+sz*cos_tilt
c
         sy1=sy
         rtot=sqrt(sx1**2+sy1**2+sz1**2)
         if(sz1.ge.0)then
          colat=acos(sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=90.-colat
         else
          colat=acos(-sz1/rtot)
          colat=57.296*colat/(sqrt(rtot))
          alat=-(90.-colat)
         endif
c
c          find local time
c
         if(sy1.gt.0.)then
          alt=atan2(sy1,sx1)
          alt=12.*alt/3.1416
         else
          alt=atan2(-sy1,sx1)
          alt=12.*(2.-alt/3.1416)
         endif
         arad=1.
c        write(wd1,'(f5.1)')arad
c        write(wd2,'(f5.1)')alat
c        write(wd3,'(f5.1)')alt
c        title=wd1//','//wd2//','//wd3//' '
c        call wtstr(.4,.9-wspace*(nspace-1),title,1,0,0)
c        write(title,'(i2)')n
c        title='craft lat,MLT'//title
c        call wtstr(.20,.9-wspace*(nspace-1),title,1,0,0)
      endif

c
         do 310 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
         xray1(nn)=1.+(xray(nn)-xmin)/delx
         yray1(nn)=1.+(yray(nn)-ymin)/dely
         zray1(nn)=1.+(zray(nn)+height-zmin)/delz
  310   continue
c
c       make color choice and plot the grap
c
c        call sflush
c        call gsplci(9)
         call curve3(xray1,yray1,zray1,npts)
c
c          2d plot
c
c        side=(-1.)**n
c        do 315 nn=1,npts
c
c        convert spatial cordinate to grid cordinate
c
c        ar=sqrt((yray(nn)-ydip)**2+(zray(nn)-zdip)**2)
c        ar=sign(ar,yray(nn))
c        ar=sign(ar,xcraft(2,n))
c        ar=ar*side
c        xray1(nn)=1.+(xray(nn)-xmin)/delx
c        yray1(nn)=1.+(yray(nn)-ymin)/dely 
c        yray1(nn)=1.+(ar-ymin)/dely
c        zray1(nn)=1.
c 315   continue
c        call sflush
c        call gsplci(1)
c        call curve3(xray1,yray1,zray1,npts)
c
  330 continue
c
c     put color bar
c
c     call set(0.,1.,0.,1.,0.,1.,0.,1.,1)
c     call gsfais(1)
c     call lbseti('CBL',1)
c     call pcsetr('CS',1.25)
c     call lblbar(0,0.1,0.9,0.,.1,ncon,1.,.3,lind,0,llbs,ncon,1)
c
c      make a 2-D cross tail cut for either IMP 8 and Geotail
c
c     abit=1.
c     avalue=10.
c     value=10.*avalue
c     fmin=tmi
c     fmax=tma
c
c     do 450 n=ncraft,2,-1
c        ax=xcraft(1,n)/re_equiv
c        ay=xcraft(2,n)/re_equiv
c        az=xcraft(3,n)/re_equiv
c        if( (ax.lt.xmin+abit).or.(ax.gt.xmax-abit).or.
c    +       (ay.lt.ymin+abit).or.(ay.gt.ymax-abit).or.
c    +       (az.lt.zmin+abit).or.(az.gt.zmax-abit) )goto 470
c
c         xp=1.+(ax-xmin)/delx
c         i1=xp+1
c         i2=i1+1
c         dx=xp-(i1-1.)
c         ddx=1.-dx
c
c         yp=1.+(ay-ymin)/dely
c         j1=yp+1
c         j2=j1+1
c         dy=yp-(j1-1.)
c         ddy=1.-dy
c
c         zp=1.+(az-zmin)/delz
c         k1=zp+1
c         k2=k1+1
c         dz=zp-(k1-1.)
c         ddz=1.-dz
c
c         do 410 k=1,mz
c         do 410 j=1,my
c            cross(j,k)=t(i1,j,k)*ddx+
c    +                       t(i2,j,k)*dx
c 410   continue
c
c     call frame
c     call gselnt(0)
c     call gsplci(1)
c     call agseti('FRAME.',2)
c     call agseti('SET.',-1)
c
c     write(title,'(f7.3)')time
c     title='UT = '//title
c     call wtstr(.7,.975,title,2,0,0)
c     call wtstr(.4,.975,label,2,0,0)
c     write(title,'(f7.4)')fmin
c     title='fmin'//title
c     call wtstr(.15,.98,title,1,0,0)
c     write(title,'(f7.4)')fmax
c     title='fmax'//title
c     call wtstr(.3,.98,title,1,0,0)
c     title='Y-Z Plane'
c     call wtstr(.9,.98,title,1,0,0)
c     clev=(fmax-fmin)/(ncon+1.)
c     if(.not.start) call cnrccf(cross,my,my,mz,fmin,
c    +             fmax,clev,0,-1,-1012,2.5,0,1)
c     IRECMN=18
c     call conrec(cross,my,my,mz,fmin,
c    +             fmax,clev,0,-1,-1012)
c
c     draw in position of spacecraft
c
c       call gsplci(16)
c        nl=11
c        n2=(nl-1)/2
c       do nn=1,nl
c         ns=(nn-n2)/2
c         shift=ns*.025
c         xrays(1)=yp-.5
c         xrays(2)=yp+.5
c         yrays(1)=zp+shift
c         yrays(2)=zp+shift
c         call curve(xrays,yrays,2)
c         xrays(1)=yp+shift
c         xrays(2)=yp+shift
c         yrays(1)=zp+.5
c         yrays(2)=zp-.5
c       call curve(xrays,yrays,2)
c       enddo
c 450 continue
c
c      make an equatoiral cut for either IMP 8 and Geotail
c
c 470 do 490 n=ncraft,2,-1
c        ax=xcraft(1,n)/re_equiv
c        ay=xcraft(2,n)/re_equiv
c        az=xcraft(3,n)/re_equiv
c        if( (ax.lt.xmin+abit).or.(ax.gt.xmax-abit).or.
c    +       (ay.lt.ymin+abit).or.(ay.gt.ymax-abit).or.
c    +       (az.lt.zmin+abit).or.(az.gt.zmax-abit) )goto 500
c
c         xp=1.+(ax-xmin)/delx
c         i1=xp+1
c         i2=i1+1
c         dx=xp-(i1-1.)
c         ddx=1.-dx
c
c         yp=1.+(ay-ymin)/dely
c         j1=yp+1
c         j2=j1+1
c         dy=yp-(j1-1.)
c         ddy=1.-dy
c
c         zp=1.+(az-zmin)/delz
c         k1=zp+1
c         k2=k1+1
c         dz=zp-(k1-1.)
c         ddz=1.-dz
c
c         do 480 i=1,mx
c         do 480 j=1,my
c            along(i,j)=t(i,j,k1)*ddz+
c    +                       t(i,j,k2)*dz
c 480   continue
c
c     call frame
c     call gselnt(0)
c     call gsplci(1)
c     call agseti('FRAME.',2)
c     call agseti('SET.',-1)
c
c     write(title,'(f7.3)')time
c     title='UT = '//title
c     call wtstr(.7,.975,title,2,0,0)
c     call wtstr(.4,.975,label,2,0,0)
c     write(title,'(f7.4)')fmin
c     title='fmin'//title
c     call wtstr(.15,.98,title,1,0,0)
c     title='fmax'//title
c     write(title,'(f7.4)')fmax
c     call wtstr(.3,.98,title,1,0,0)
c     title='X-Y Plane'
c     call wtstr(.9,.98,title,1,0,0)
c     clev=(fmax-fmin)/(ncon+1.)
c     if(.not.start) then
c        call cnrccf(along,mx,mx,my,fmin,
c    +             fmax,clev,0,-1,-1012,2.5,0,1)
c     else
c       IRECMN=18
c       call conrec(along,mx,mx,my,fmin,
c    +             fmax,clev,0,-1,-1012)
c     endif
c
c     draw in position of spacecraft
c
c       call gsplci(16)
c        nl=11
c        n2=(nl-1)/2
c       do nn=1,nl
c         ns=(nn-n2)/2
c         shift=ns*.025
c         xrays(1)=xp-.5
c         xrays(2)=xp+.5
c         yrays(1)=yp+shift
c         yrays(2)=yp+shift
c         call curve(xrays,yrays,2)
c         xrays(1)=xp+shift
c         xrays(2)=xp+shift
c         yrays(1)=yp+.5
c         yrays(2)=yp-.5
c       call curve(xrays,yrays,2)
c       enddo
c 490 continue
c
c      make a 2-D along tail cut for either IMP 8 and Geotail
c
c 500 do 530 n=ncraft,2,-1
c        ax=xcraft(1,n)/re_equiv
c        ay=xcraft(2,n)/re_equiv
c        az=xcraft(3,n)/re_equiv
c        if( (ax.lt.xmin+abit).or.(ax.gt.xmax-abit).or.
c    +       (ay.lt.ymin+abit).or.(ay.gt.ymax-abit).or.
c    +       (az.lt.zmin+abit).or.(az.gt.zmax-abit) )return
c
c         xp=1.+(ax-xmin)/delx
c         i1=xp+1
c         i2=i1+1
c         dx=xp-(i1-1.)
c         ddx=1.-dx
c
c         yp=1.+(ay-ymin)/dely
c         j1=yp+1
c         j2=j1+1
c         dy=yp-(j1-1.)
c         ddy=1.-dy
c
c         zp=1.+(az-zmin)/delz
c         k1=zp+1
c         k2=k1+1
c         dz=zp-(k1-1.)
c         ddz=1.-dz
c
c         do 520 i=1,mx
c         do 520 k=1,mz
c            along(i,k)=t(i,j1,k)*ddy+
c    +                       t(i,j2,k)*dy
c 520   continue
c
c     call frame
c     call gselnt(0)
c     call gsplci(1)
c     call agseti('FRAME.',2)
c     call agseti('SET.',-1)
c
c     write(title,'(f7.3)')time
c     title='UT = '//title
c     call wtstr(.7,.975,title,2,0,0)
c     call wtstr(.4,.975,label,2,0,0)
c     write(title,'(f7.4)')fmin
c     title='fmin'//title
c     call wtstr(.15,.98,title,1,0,0)
c     title='fmax'//title
c     write(title,'(f7.4)')fmax
c     call wtstr(.3,.98,title,1,0,0)
c     title='X-Z Plane'
c     call wtstr(.9,.98,title,1,0,0)
c     clev=(fmax-fmin)/(ncon+1.)
c     if(.not.start) then
c        call cnrccf(along,mx,mx,mz,fmin,
c    +             fmax,clev,0,-1,-1012,2.5,0,1)
c     else
c       IRECMN=18
c       call conrec(along,mx,mx,mz,fmin,
c    +             fmax,clev,0,-1,-1012)
c     endif
c
c     draw in position of spacecraft
c
c       call gsplci(16)
c        nl=11
c        n2=(nl-1)/2
c       do nn=1,nl
c         ns=(nn-n2)/2
c         shift=ns*.025
c         xrays(1)=xp-.5
c         xrays(2)=xp+.5
c         yrays(1)=zp+shift
c         yrays(2)=zp+shift
c         call curve(xrays,yrays,2)
c         xrays(1)=xp+shift
c         xrays(2)=xp+shift
c         yrays(1)=zp+.5
c         yrays(2)=zp-.5
c       call curve(xrays,yrays,2)
c       enddo
c 530 continue
c
      return
      end
c
c     **********************************************************
c
      subroutine cpclrs
      dimension rgbv(3,12)
c
c      8 basic colors, 4 extras for curve tracing, 15 more for isoplots
c
      data  rgbv/0.,0.,0.,     !black
     +           1.,0.,0.,     !red
     +           0.,1.,0.,     !green
     +           0.,0.,1.,     !blue
     +           0.,1.,1.,     !cyan
     +           1.,0.,1.,     !magenta
     +           1.,1.,0.,     !yellow
     +           0.5, 1.0, 0.5,     !bright green
     +           1.0, 0.5, 1.0,     !bright pink
     +           0.3, 1.0, 1.0,     !bright blue
     +           1.0, 1.0, 0.3,     !bright yellow
     +           1.,1.,1./     !white
c
      call gscr(1,0,1.,1.,1.)
c
      do 101 i = 1, 12
        call gscr(1,i,rgbv(1,i),rgbv(2,i),rgbv(3,i))
  101 continue
c
      return
      end
c 
c     ***************************************************** 
c 
      subroutine isoclrs_hot
      dimension rgbv(3,21)
c
c     arrays to plot colorbar
c
      integer lind(20)
      real tcon(20)
      character*4 llbs(20)
c  
      data rgbv/0.,0.,0., .7,.7,.7, .75,.5,1.,
     &          .5,0.,1.,.25,0.,1.,  0.,0.,1., 0.,.25,1.,
     &         0.,.5,1., 0.,1.,1., 0.,1.,.6, 0.,.85,0.,
     &         0.3,.85,0., .7,1.,0., 1.,1.,0., 1.,.75,0.,
     &          1.,.38,.38,  1.,0.2,.2,
     &         1.,0.1,0.1, 1.,0.,0., 0.85,0.,0.,1.,1.,1./
      call gscr(1,0,1.,1.,1.)
      do 101 i=1,21
      call gscr(1,i,rgbv(1,i),rgbv(2,i),rgbv(3,i))
  101 continue
      return
      end
c
c     *****************************************************
c
      subroutine isoclrs
      dimension rgbv(3,16)
      data rgbv/0.,0.,0., .7,.7,.7, .75,.5,1.,
     &          .5,0.,1., 0.,0.,1.,  0.,.5,1.,
     &          0.,1.,1., 0.,1.,.6, 0.,.85,0.,
     &          .7,1.,0., 1.,1.,0., 1.,.75,0.,
     &          1.,.38,.38,  1.,0.,.75,
     &          1.,0.,0.,  1.,1.,1./
      call gscr(1,0,1.,1.,1.)
      do 101 i=1,16
      call gscr(1,i,rgbv(1,i),rgbv(2,i),rgbv(3,i))
  101 continue
      return
      end
c
c     *****************************************************
c
      subroutine isorb
      dimension rgbv(3,16)
      data rgbv/0.,0.,0., .7,.7,.7, .75,.5,1.,
     &          .5,0.,1., 0.,0.,1.,  0.,.5,1.,
     &          0.,1.,1., 0.,1.,.6, 
     &          1.,.38,.38,  1.,0.,.38,
     &          1.,0.,0.,  0.,0.65,0.,
     &          0.,.85,0., .7,1.,0.,
     &          1.,1.,0., 1.,.75,0./
      call gscr(1,0,1.,1.,1.)
      do 101 i=1,16 
      call gscr(1,i,rgbv(1,i),rgbv(2,i),rgbv(3,i))
  101 continue 
      return
      end 
      SUBROUTINE CNRCCF(ZDAT,KZDT,MZDT,NZDT,FLOW,FHGH,FINC,NSET,NHGH,
     &   NDSH,SMOOTH,LINES,ICOLFG)
C
C  A version of the old CONREC which does color-filled contours.  This
C  is a modified CPCNRC which was written by Dave Kennison.  It requires
C  the CONPACK library.   The first ten arguments are identical to the
C  old CONREC call.
C
C  SMOOTH - zero for no smoothing; small values (e.g. .001) yield
C     approximately cubic splines; large values (e.g. 50.) yield nearly
C     polygonal curves; suggested starting value is 2.5; if negative,
C     smoothing is done before coordinate mapping
C
C  LINES - if nonzero, contour lines are drawn in the foreground color
C
C  ICOLFG - if zero, a default color table is used; if nonzero, user
C     must set color indices 2 to NCL+2, where NCL = number of contour
C     levels.  The number of colors required is always one more than the
C     number of contour levels.  Color index numbering for associated
C     contour fill colors must begin with 2 since color indices 0 and 1
C     are reserved for background and foreground, respectively.  These
C     may be set by the user regardless of the value of ICOLFG.
C     Choosing the default color table will reset indices 2 to MAXCOL.
C     A subset of these will actually be used.  See routine DFCLRS for
C     the value of MAXCOL.
C
      DIMENSION ZDAT(KZDT,*)
C
C Define some needed dimensions.
C
      PARAMETER (LAMA=100000,LRWK=2000,LIWK=1000,NCRA=2000,NGRPS=10,
     &   LOCV=10)
C
C Define required workspace arrays.
C
      DIMENSION RWRK(LRWK),IWRK(LIWK),IAMA(LAMA),XCRA(NCRA),YCRA(NCRA),
     &   IAIA(NGRPS),IGIA(NGRPS),REC(4)
C
C Define a character variable to use for point-value labelling.
C
      CHARACTER*(LOCV) CROZ
      CHARACTER*100 ILTS
      COMMON/MAPAWM/KLAT,ICMP,ICON
C
C Declare the contour-line drawing routine.
C
      EXTERNAL COLRAM
C
C  ..Set GKS internal parameters
C
      CALL GQCLIP(IER,ICLIP,REC)
      CALL GQFAIS(IER,IFAIS)
      CALL GSCLIP(0)
      CALL GSFAIS(1)
C
C  ..Set the tension on the two dimensional smoother
C
      CALL CPSETR('T2D',SMOOTH)
C
C Arrange for the selection of contour levels as desired by the user.
C
      IF (FINC.LT.0.) THEN
         CALL CPSETI('CLS - contour level selector',MAX(1,INT(-FINC)))
         CALL CPSETR('CIS - contour interval specifier',0.)
      ELSEIF (FINC.EQ.0.) THEN
         CALL CPSETI('CLS - contour level selector',16)
         CALL CPSETR('CIS - contour interval specifier',0.)
      ELSE
         CALL CPSETI('CLS - contour level selector',1)
         CALL CPSETR('CIS - contour interval specifier',FINC)
         IF (FLOW.LT.FHGH) THEN
            CALL CPSETR('CMN - contour minimum',FLOW)
            CALL CPSETR('CMX - contour maximum',FHGH)
         ENDIF
      ENDIF
C
C Set up the desired mapping of output onto the plotter frame.
C
      IF (NSET.LT.0) THEN
         CALL CPSETI('SET - do-set-call flag',1)
         CALL GETSET(XVPL,XVPR,YVPB,YVPT,XWDL,XWDR,YWDB,YWDT,LNLG)
         CALL CPSETR('VPL - viewport left edge',XVPL)
         CALL CPSETR('VPR - viewport right edge',XVPR)
         CALL CPSETR('VPB - viewport bottom edge',YVPB)
         CALL CPSETR('VPT - viewport top edge',YVPT)
         CALL CPSETI('VPS - viewport shape',0)
      ELSEIF (NSET.EQ.0) THEN
         CALL CPSETI('SET - do-set-call flag',1)
         CALL CPSETR('VPL - viewport left edge',.05)
         CALL CPSETR('VPR - viewport right edge',.95)
         CALL CPSETR('VPB - viewport bottom edge',.05)
         CALL CPSETR('VPT - viewport top edge',.95)
         CALL CPSETI('VPS - viewport shape',4)
      ELSE
         CALL CPSETI('SET - do-set-call flag',0)
      ENDIF
C
C Decide what dash pattern to use.
C
      IF (LINES.NE.0) THEN
         IDSH=ABS(NDSH)
         IF (IDSH.EQ.0.OR.IDSH.EQ.1.OR.IDSH.EQ.1023) THEN
            IDSH=IOR(ISHIFT(32767,1),1)
         ELSE
            IDSH=IOR(ISHIFT(IDSH,6),IAND(ISHIFT(IDSH,-4),63))
         ENDIF
      ENDIF
C
C Decide whether to label highs and lows or not.
C
      IF (NHGH.EQ.0) THEN
         CALL CPSETC('HLT - high/low label text',
     &      'H:B:$ZDV$:E:''L:B:$ZDV$:E:')
      ELSE
         CALL CPSETC('HLT - high/low label text',' ')
      ENDIF
C
C Initialize CONPACK and give it all array dimensions.
C
      CALL CPRECT(ZDAT,KZDT,MZDT,NZDT,RWRK,LRWK,IWRK,LIWK)
C
C Pick contour levels.
C
      CALL CPPKCL(ZDAT,RWRK,IWRK)
C
C Retrieve the contour levels selected, one at a time.  Discard levels
C which are outside the range, if any, specified by the user-supplied
C values of FLOW and FHGH, and move the parameters for all remaining
C levels to the beginning of the parameter arrays.  Set dash patterns
C for all levels.  The value of 'CIU' must be saved for possible
C restoration if it gets clobbered as a side effect of setting contour
C level 1.
C
      CALL CPGETR('CIU - contour interval used',CINU)
      CALL CPGETI('NCL - number of contour levels',NCLO)
      NCLN=0
      DO 1 ICLO=1,NCLO
      CALL CPSETI('PAI - parameter array index',ICLO)
      CALL CPGETR('CLV - contour level',CLEV)
      IF (FLOW.GE.FHGH.OR.(CLEV.GE.FLOW.AND.CLEV.LE.FHGH)) THEN
         NCLN=NCLN+1
         IF (NCLN.NE.ICLO) THEN
            CALL CPGETI('CLU - contour level use flag',ICLU)
            CALL CPSETI('PAI - parameter array index',NCLN)
            CALL CPSETR('CLV - contour level',CLEV)
            CALL CPSETI('CLU - contour level use flag',ICLU)
            CALL CPSETI('AIA - area identifier above level',NCLN+1)
            CALL CPSETI('AIB - area identifier below level',NCLN)
            CALL CPSETI('CLC - contour line color index',-1)
            CALL CPSETC('CLD - contour line dash pattern',
     &         '$$$$$$$$$$$$$$$$')
            CALL CPSETI('CLL - contour line line width',-1)
            CALL CPSETI('LLC - line label color index',-1)
            CALL CPSETC('LLT - line label text',' ')
         ENDIF
      ENDIF
      IF (NDSH.GT.0.OR.(NDSH.LT.0..AND.CLEV.LT.0.))
     &   CALL CPSETI('CLD - contour line dash pattern',IDSH)
    1 CONTINUE
C
C Log an error if no contour levels were within the user's bounds.
C
      IF (NCLN.EQ.0) THEN
         CALL SETER('CNRCCF - no contour levels in specified range',
     &      1,2)
         RETURN
      ENDIF
C
C If the number of contour levels decreased, reset parameters affected.
C
      IF (NCLN.LT.NCLO) THEN
         CALL CPSETI('NCL - number of contour levels',NCLN)
         CALL CPSETR('CIU - contour interval used',CINU)
      ENDIF
C
C  ..Default color table
C
      IF (ICOLFG.EQ.0) THEN
         NCOL=NCLN+1
         CALL DFCLRS(NCOL)
      ENDIF
C
C  ..Color filled contour
C
      CALL ARINAM(IAMA,LAMA)
      CALL CPCLAM(ZDAT,RWRK,IWRK,IAMA)
      CALL ARSCAM(IAMA,XCRA,YCRA,NCRA,IAIA,IGIA,NGRPS,COLRAM)
C
C  ..Map
C
C     CALL GETUSV('II',ICOLOR)
C     CALL SETUSV('II',ICMP)
C     CALL MAPGRD
C     CALL MAPLBL
C     CALL SETUSV('LW',2000)
C     CALL MAPLOT
C     CALL SETUSV('LW',1000)
C     CALL MAPLBM
C     CALL SETUSV('II',ICOLOR)
C
C If requested, put out a simple background.
C
      IF (NSET.EQ.0) CALL CPBACK(ZDAT,RWRK,IWRK)
C
C See how the user has chosen to position contour levels.
C
      CALL CPGETI('LLP - line label positioning flag',LLPF)
C
C Draw the contour lines, masking them if necessary.
C
      IF (LINES.NE.0) THEN
         IF (LLPF.LE.1) THEN
            CALL GQPLCI(IER,ICOLOR)
            CALL GSPLCI(0)
            CALL CPCLDR(ZDAT,RWRK,IWRK)
            CALL GSPLCI(ICOLOR)
         ELSE
            CALL ARINAM(IAMA,LAMA)
            CALL CPLBAM(ZDAT,RWRK,IWRK,IAMA)
            CALL CPCLDM(ZDAT,RWRK,IWRK,IAMA,CPDRPL)
         ENDIF
      ENDIF
C
C Plot labels.
C
      CALL CPGETC('ILT - informational label text',ILTS)
C     PRINT*,'Informational label is ',ILTS
      CALL CPLBDR(ZDAT,RWRK,IWRK)
C
C If requested, label every point on the grid.
C
      IF (NHGH.GT.0) THEN
         CALL GETSET(XVPL,XVPR,YVPB,YVPT,XWDL,XWDR,YWDB,YWDT,LNLG)
         CALL CPGETR('CWM - character width multiplier',CHWM)
         CALL CPGETR('HLA - high/low label angle',ANGD)
         CALL CPGETR('HLS - high/low label size',SIZE)
         CALL CPGETI('MAP - mapping flag',IMAP)
         CALL CPGETR('ORV - out-of-range value',ORVA)
         CALL CPGETR('SPV - special value',SPVA)
         CALL CPGETR('XC1 - x coordinate at i = 1',XCA1)
         CALL CPGETR('XCM - x coordinate at i = m',XCAM)
         CALL CPGETR('YC1 - y coordinate at j = 1',YCA1)
         CALL CPGETR('YCN - y coordinate at j = n',YCAN)
         SIZE=(XVPR-XVPL)*CHWM*SIZE
         IF (XCA1.EQ.XCAM) THEN
            XCA1=1.
            XCAM=REAL(MZDT)
         ENDIF
         IF (YCA1.EQ.YCAN) THEN
            YCA1=1.
            YCAN=REAL(NZDT)
         ENDIF
         DO 4 J=1,NZDT
         YPOS=YCA1+REAL(J-1)*(YCAN-YCA1)/REAL(NZDT-1)
         DO 4 I=1,MZDT
         XPOS=XCA1+REAL(I-1)*(XCAM-XCA1)/REAL(MZDT-1)
         IF (SPVA.EQ.0..OR.ZDAT(I,J).NE.SPVA) THEN
            CALL CPSETR('ZDV - z data value',ZDAT(I,J))
            CALL CPGETC('ZDV - z data value',CROZ)
            DO 2 K=LOCV,2,-1
            IF (CROZ(K:K).NE.' ') THEN
               LCRZ=K
               GOTO 3
            ENDIF
    2       CONTINUE
            LCRZ=1
    3       IF (IMAP.EQ.0) THEN
               CALL PLCHHQ(XPOS,YPOS,CROZ(1:LCRZ),SIZE,ANGD,0.)
            ELSE
               CALL CPMPXY(IMAP,XPOS,YPOS,XMPD,YMPD)
               IF (ORVA.EQ.0..OR.XMPD.NE.ORVA)
     &            CALL PLCHHQ(XMPD,YMPD,CROZ(1:LCRZ),SIZE,ANGD,0.)
            ENDIF
         ENDIF
    4    CONTINUE
      ENDIF
C
C  ..Reset GKS internal parameters
C
      CALL GSCLIP(ICLIP)
      CALL GSFAIS(IFAIS)
      RETURN
      END
      SUBROUTINE DFCLRS(NCOL)
C
C  Reads from the default input ($IN on the Cray) a color table of
C  MAXCOL colors in free format 8-bit integer RGB values (i.e. 0 to 255)
C  and selects NCOL colors evenly distributed among the MAXCOL colors;
C  these are bound to color indices 2 to NCOL+1
C
      PARAMETER (MAXCOL=250)
      DIMENSION IRGBV(3,MAXCOL)
      DATA ICALL/0/
      SAVE ICALL,IRGBV
      IF (NCOL.GT.0.AND.NCOL.LE.MAXCOL) GOTO 1
      PRINT*,'STOP in DFCLRS - input parameter NCOL out of range'
      PRINT*,'NCOL = ',NCOL
      STOP
    1 IF (ICALL.EQ.1) GOTO 2
      ICALL=1
      READ(9,*) IRGBV
    2 AINC=REAL(MAXCOL-1)/REAL(NCOL-1)
      DO 3 JJ=2,NCOL+1
      J=NINT(AINC*(JJ-2))+1
      R=IRGBV(1,J)/255.
      G=IRGBV(2,J)/255.
      B=IRGBV(3,J)/255.
    3 CALL GSCR(1,JJ,R,G,B)
      RETURN
      END
      SUBROUTINE COLRAM(XCRA,YCRA,NCRA,IAIA,IGIA,NAIA)
      DIMENSION XCRA(*),YCRA(*),IAIA(*),IGIA(*)
      IF (IAIA(1).LE.0) RETURN
C
C  ..Area numbering starts with 1, but color index numbering starts
C    with 2 because 0 and 1 are reserved for background and foreground,
C    respectively
C
      CALL GSFACI(IAIA(1))
      CALL GFA(NCRA-1,XCRA,YCRA)
      RETURN
      END


